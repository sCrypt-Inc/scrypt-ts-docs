"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[7653],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=s(n),h=o,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||r;return n?a.createElement(m,c(c({ref:t},p),{},{components:n})):a.createElement(m,c({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,c=new Array(r);c[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,c[1]=i;for(var s=2;s<r;s++)c[s]=n[s];return a.createElement.apply(null,c)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4842:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:1},c="How to Deploy & Call a Contract",i={unversionedId:"how-to-deploy-and-call-a-contract/how-to-deploy-and-call-a-contract",id:"how-to-deploy-and-call-a-contract/how-to-deploy-and-call-a-contract",title:"How to Deploy & Call a Contract",description:"Setup",source:"@site/docs/how-to-deploy-and-call-a-contract/how-to-deploy-and-call-a-contract.md",sourceDirName:"how-to-deploy-and-call-a-contract",slug:"/how-to-deploy-and-call-a-contract/",permalink:"/docs/how-to-deploy-and-call-a-contract/",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"How to Test a Contract",permalink:"/docs/how-to-test-a-contract"},next:{title:"How to Customize a Contract Tx",permalink:"/docs/how-to-deploy-and-call-a-contract/how-to-customize-a-contract-tx"}},l={},s=[{value:"Setup",id:"setup",level:2},{value:"Use the Sensilet Wallet",id:"use-the-sensilet-wallet",level:3},{value:"Introduction",id:"introduction",level:2},{value:"Tx Builders",id:"tx-builders",level:3},{value:"Contract Deployment Transaction",id:"contract-deployment-transaction",level:4},{value:"Contract Call Transaction",id:"contract-call-transaction",level:4},{value:"Prepare a Signer and Provider",id:"prepare-a-signer-and-provider",level:2},{value:"Contract Deployment",id:"contract-deployment",level:2},{value:"Contract Call",id:"contract-call",level:2},{value:"Create a smart contract instance from a transaction",id:"create-a-smart-contract-instance-from-a-transaction",level:3},{value:"Method with Signatures",id:"method-with-signatures",level:3},{value:"Example",id:"example",level:2},{value:"Running the code",id:"running-the-code",level:3},{value:"Customize Transactions",id:"customize-transactions",level:3}],p={toc:s};function d(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-to-deploy--call-a-contract"},"How to Deploy & Call a Contract"),(0,o.kt)("h2",{id:"setup"},"Setup"),(0,o.kt)("p",null,"It is highly recommended to test your contract on the ",(0,o.kt)("a",{parentName:"p",href:"https://test.whatsonchain.com/"},"testnet")," after passing local tests. It ensures that a contract can be successfully deployed and invoked as expected on the blockchain."),(0,o.kt)("p",null,"Before deploy and call a contract, you need to:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Generate a private key with the following command:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"npm run genprivkey\n")),(0,o.kt)("p",null,"The command will generate a private key and store it in a ",(0,o.kt)("inlineCode",{parentName:"p"},".env")," file in our project's root directory. It also outputs the ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.bitcoinsv.io/index.php/Bitcoin_address"},"Bitcoin address")," corresponding to our private key. "),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Fund the private key's address with some testnet coins. You could use this ",(0,o.kt)("a",{parentName:"li",href:"https://scrypt.io/faucet"},"facuet")," to receive test coins.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"facuet",src:n(7130).Z,width:"2048",height:"1152"})),(0,o.kt)("h3",{id:"use-the-sensilet-wallet"},"Use the Sensilet Wallet"),(0,o.kt)("p",null,"Alternatively, if you have already installed ",(0,o.kt)("a",{parentName:"p",href:"https://sensilet.com/"},"Sensilet"),", you can extract and use its private key on testnet as follows."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(3384).Z,width:"2000",height:"1216"})),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"After you've finished writing a contract, you can deploy and call it. But first, you should learn how the a smart contract interacts with the blockchain."),(0,o.kt)("p",null,"As explained in the ",(0,o.kt)("a",{parentName:"p",href:"/docs/overview"},"Overview section"),", an ",(0,o.kt)("inlineCode",{parentName:"p"},"sCrypt")," contract is based on the Bitcoin UTXO model. A ",(0,o.kt)("strong",{parentName:"p"},"constract instance")," is an abstraction that represents a specific contract deployed on-chain, so you can use it to interact with the contract like a normal TypeScript object. In this section, we will go over some fundamental concepts in details."),(0,o.kt)("h3",{id:"tx-builders"},"Tx Builders"),(0,o.kt)("p",null,"To deploy or interact with contracts, we must build transactions and broadcast them to Bitcoin.\nWe have some built-in tx builders for the most common way to interact with contracts, so usually you don't have to implement them. If the default tx builder does not meet your specific requirements, such as having extra inputs or outputs in your tx, you can ",(0,o.kt)("a",{parentName:"p",href:"/docs/how-to-deploy-and-call-a-contract/how-to-customize-a-contract-tx"},"customize it"),"."),(0,o.kt)("h4",{id:"contract-deployment-transaction"},"Contract Deployment Transaction"),(0,o.kt)("p",null,"A Bitcoin transaction is required when deploying a contract to the blockchain. The transaction should have an output, whose script is compiled from the contract. This output is known as a contract UTXO and we regard the contract instance comes ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," this UTXO."),(0,o.kt)("p",null,"An instance's ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," can be accessed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// the tx that contains the instance\ninstance.from.tx\n// the index of the tx output that contains the instance\ninstance.from.outputIndex\n")),(0,o.kt)("h4",{id:"contract-call-transaction"},"Contract Call Transaction"),(0,o.kt)("p",null,"When you call a public method of a contract instance in a UTXO, a call transaction is needed. The transaction has an input that references to the UTXO and contains the script consisted of the method's arguments. We regard the contract instance goes ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," this transaction input."),(0,o.kt)("p",null,"An instance's ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," can be accessed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// the tx that spends the instance\ninstance.to.tx\n// the index of the tx input that spends the UTXO the instance is in\ninstance.to.inputIndex\n")),(0,o.kt)("p",null,"This section could be summarized as the diagram below:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(5187).Z,width:"761",height:"326"})),(0,o.kt)("h2",{id:"prepare-a-signer-and-provider"},"Prepare a Signer and Provider"),(0,o.kt)("p",null,"As we mentioned in the ",(0,o.kt)("a",{parentName:"p",href:"/docs/how-to-test-a-contract"},"testing section"),", a signer and a provider should be connected to a contract before deployment and call. "),(0,o.kt)("p",null,"For local testing, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"TestWallet")," introduced ",(0,o.kt)("a",{parentName:"p",href:"../how-to-test-a-contract#testwallet"},"before"),", with a mock provider. When we are ready to deploy the contract to the testnet/mainnet, we need a real provider like ",(0,o.kt)("a",{parentName:"p",href:"/docs/how-to-test-a-contract#provider"},"DefaultProvider"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const network = bsv.Networks.testnet; // or bsv.Networks.mainnet\nconst signer = new TestWallet(privateKey, new DefaultProvider(network));\n")),(0,o.kt)("p",null,"Don't forget to connect the signer to the contract instance as well:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"await instance.connect(signer);\n")),(0,o.kt)("h2",{id:"contract-deployment"},"Contract Deployment"),(0,o.kt)("p",null,"To deploy a smart contract, simply call its ",(0,o.kt)("inlineCode",{parentName:"p"},"deploy")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// construct a new instance of `MyContract`\nlet instance = new MyContract(...initArgs);\n\n// connect the signer to the instance\nawait instance.connect(signer);\n\n// the contract UTXO\u2019s satoshis\nconst initBalance = 1234;\n\n// build and send tx for deployment\nconst deployTx = await instance.deploy(initBalance);\nconsole.log(`Smart contract successfully deployed with txid ${tx.id}`);\n")),(0,o.kt)("h2",{id:"contract-call"},"Contract Call"),(0,o.kt)("p",null,"Similar to what we described in ",(0,o.kt)("a",{parentName:"p",href:"../how-to-test-a-contract#call-a-public-method"},"this section"),", you can call a contract's public ",(0,o.kt)("inlineCode",{parentName:"p"},"@method")," on the blockchain as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// build and send tx for calling `foo`\nconst { tx, atInputIndex } = await instance.methods.foo(arg1, arg2, opts);\nconsole.log(`Smart contract method successfully called with txid ${tx.id}`);\n")),(0,o.kt)("p",null,"The major differences between here and local tests are:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"the contract needs to be depoyed first;"),(0,o.kt)("li",{parentName:"ol"},"the contract instance is connected to a real provider, which broadcasts transactions to the blockchain.")),(0,o.kt)("h3",{id:"create-a-smart-contract-instance-from-a-transaction"},"Create a smart contract instance from a transaction"),(0,o.kt)("p",null,"To interact with a deployed smart contract (i.e., calling its public methods), we need its contract instance corresponding to its latest state on chain, stateful or not. When testing on testnet, we usually put a contract's deployment and its calling (note there could be multiple calls if the contract is stateful) in the same process for convenience, so that we don't need to manage the internal state of the instance manually, because it's always consistent with the transactions on chain."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/tests/testnet/counter.ts"},"following code")," tests the stateful contract ",(0,o.kt)("a",{parentName:"p",href:"/docs/how-to-write-a-contract/stateful-contract#create-a-stateful-contract"},"Counter"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"currentInstance")," always points to the latest instance."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const counter = new Counter(0n)\n\nawait counter.connect(getDefaultSigner())\n\n// deploy the contract first\nconst deployTx = await counter.deploy(1)\nconsole.log('Counter deploy tx:', deployTx.id)\n\n// then call the contract by reusing the same instance `counter`\nlet currentInstance = counter\n\n// call the method of current instance to apply the updates on chain\nfor (let i = 0; i < 3; ++i) {\n    // avoid mempool conflicts, sleep to allow previous tx \"sink-into\" the network\n    await sleep(2)\n\n    // create the next instance from the current\n    const nextInstance = currentInstance.next()\n\n    // apply updates on the next instance off chain\n    nextInstance.increment()\n\n    // call the method of current instance to apply the updates on chain\n    const { tx: tx_i } = await currentInstance.methods.incrementOnChain({\n        next: {\n            instance: nextInstance,\n            balance,\n        },\n    } as MethodCallOptions<Counter>)\n\n    console.log(\n        `Counter call tx: ${tx_i.id}, count updated to: ${nextInstance.count}`\n    )\n\n    // update the current instance reference\n    currentInstance = nextInstance\n}\n\n")),(0,o.kt)("p",null,"In reality, a contract's deployment and its call, and its different calls in the case of a stateful contract, may well be in separate processes. For example, the deployment party is different from the calling party, or multiple parties call it. If so, we need to create a contract instance from an on-chain transaction that represents its latest state, before we can call its method."),(0,o.kt)("p",null,"We can create an contract instance from a transaction's output by calling ",(0,o.kt)("a",{parentName:"p",href:"/docs/how-to-write-a-contract/built-ins#fromtx"},"fromTx()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// recover instance from transaction\nconst instance = Counter.fromTx(tx, atOutputIndex)\n\n// we're good here, the `instance` is now in sync with the on-chain transaction\n")),(0,o.kt)("p",null,"Let's look at a more complex example."),(0,o.kt)("h3",{id:"method-with-signatures"},"Method with Signatures"),(0,o.kt)("p",null,"A contract public ",(0,o.kt)("inlineCode",{parentName:"p"},"@method")," often needs a signature argument for authentication. Take this ",(0,o.kt)("a",{parentName:"p",href:"https://learnmeabitcoin.com/technical/p2pkh"},"Pay To Pubkey Hash (P2PKH)")," contract for example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export class P2PKH extends SmartContract {\n    @prop()\n    readonly pubKeyHash: PubKeyHash;\n\n    constructor(pubKeyHash: PubKeyHash) {\n        super(pubKeyHash);\n        this.pubKeyHash = pubKeyHash;\n    }\n\n    @method()\n    public unlock(sig: Sig, pubkey: PubKey) {\n        // make sure the `pubkey` is the one locked with its hash value in the constructor\n        assert(hash160(pubkey) == this.pubKeyHash, 'pubKeyHash check failed');\n\n       // make sure the `sig` is signed by the private key corresponding to the `pubkey`\n        assert(this.checkSig(sig, pubkey), 'signature check failed');\n    }\n}\n")),(0,o.kt)("p",null,"We can call the ",(0,o.kt)("inlineCode",{parentName:"p"},"unlock")," method like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// call\nconst { tx: callTx } = await p2pkh.methods.unlock(\n    // the first argument `sig` is replaced by a callback function which will return the needed signature\n    (sigResps) => findSig(sigResps, publicKey),\n\n    // the second argument is still the value of `pubkey`\n    PubKey(toHex(publicKey)),\n\n    // method call options\n    {\n        // A request for signer to sign with the private key corresponding to a public key\n        pubKeyOrAddrToSign: publicKey\n    } as MethodCallOptions<P2PKH>\n);\n\nconsole.log('contract called: ', callTx.id);\n\n")),(0,o.kt)("p",null,"When ",(0,o.kt)("inlineCode",{parentName:"p"},"p2phk.method.unlock")," is called, the option contains ",(0,o.kt)("inlineCode",{parentName:"p"},"pubKeyOrAddrToSign"),", requesting a signature against ",(0,o.kt)("inlineCode",{parentName:"p"},"publicKey"),"."),(0,o.kt)("p",null,"The first argument is a signature, which can be obtained in a callback function. The function takes a list of signatures requested in ",(0,o.kt)("inlineCode",{parentName:"p"},"pubKeyOrAddrToSign")," and find the one signature to the right public key/address."),(0,o.kt)("p",null,"In general, if your ",(0,o.kt)("inlineCode",{parentName:"p"},"@method")," needs ",(0,o.kt)("inlineCode",{parentName:"p"},"Sig"),"-typed arguments, you could obtain them as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Ensure that the ",(0,o.kt)("inlineCode",{parentName:"p"},"pubKeyOrAddrToSign")," contains all public keys/addresses corresponding to these ",(0,o.kt)("inlineCode",{parentName:"p"},"Sig"),"s;")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Replace each ",(0,o.kt)("inlineCode",{parentName:"p"},"Sig")," argument with a callback function that filters to the right ",(0,o.kt)("inlineCode",{parentName:"p"},"Sig")," from the full list of signature in ",(0,o.kt)("inlineCode",{parentName:"p"},"sigResps"),"."))),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"Here is the complete sample code for the deployment and call of a P2PKH contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { privateKey } from '../../utils/privateKey';\n\n// compile contract\nawait P2PKH.compile()\n\n// public key of the `privateKey`\nconst publicKey = privateKey.publicKey\n// hash of the `publicKey`\nconst pkh = bsv.crypto.Hash.sha256ripemd160(publicKey.toBuffer())\n\n// setup signer\nconst signer = new TestWallet(privateKey, new DefaultProvider());\n\n// initialize an instance with `pkh`\nlet p2pkh = new P2PKH(PubKeyHash(toHex(pkh)))\n\n// connect the signer\nawait p2pkh.connect(signer);\n\n// deploy the contract, with 1 satoshi locked in\nconst deployTx = await p2pkh.deploy(1);\nconsole.log('contract deployed: ', deployTx.id);\n\n// call\nconst { tx: callTx } = await p2pkh.methods.unlock(\n    (sigResps) => findSig(sigResps, publicKey),\n    PubKey(toHex(publicKey)),\n    {\n        pubKeyOrAddrToSign: publicKey\n    } as MethodCallOptions<P2PKH>\n);\n\nconsole.log('contract called: ', callTx.id);\n\n")),(0,o.kt)("p",null,"More examples can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/tree/master/tests/testnet"},"here"),"."),(0,o.kt)("h3",{id:"running-the-code"},"Running the code"),(0,o.kt)("p",null,"The deployment and call code is wrapped into a simple NPM command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"npm run testnet\n")),(0,o.kt)("p",null,"Make sure you fund your address before running this command.\nAfter a successful run you should see something like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Demo contract deployed:  f3f372aa25f159efa93db8c51a4eabbb15935358417ffbe91bfb78f4f0b1d2a3\nDemo contract called:  dc53da3e80aadcdefdedbeb6367bb8552e381e92b226ab1dc3dc9b3325d8a8ee\n")),(0,o.kt)("p",null,"These are the TXIDs of the transaction which deployed the smart contract and then the one which called its method. You can see the transactions using a ",(0,o.kt)("a",{parentName:"p",href:"https://test.whatsonchain.com/tx/f3f372aa25f159efa93db8c51a4eabbb15935358417ffbe91bfb78f4f0b1d2a3"},"block explorer"),"."),(0,o.kt)("h3",{id:"customize-transactions"},"Customize Transactions"),(0,o.kt)("p",null,"Deploying and calling a contract builds transactions with a certain format, which suffices for many cases. In cases where the tx format does not work for you and you need to customize it, please refer to ",(0,o.kt)("a",{parentName:"p",href:"/docs/how-to-deploy-and-call-a-contract/how-to-customize-a-contract-tx"},"this section"),"."))}d.isMDXComponent=!0},5187:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/contract_tx-0fa71f4c422b61213b4fd38744df2650.svg"},3384:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/extract-sensilet-private-key-633fda649cf6e064f36c8f8ecb9b1671.gif"},7130:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/faucet-4f5143be4f0b79eebf8ddf87470cf7a4.gif"}}]);