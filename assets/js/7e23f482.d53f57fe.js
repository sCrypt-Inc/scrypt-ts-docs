"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[5243],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),s=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return i.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=s(n),h=o,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||a;return n?i.createElement(d,r(r({ref:t},p),{},{components:n})):i.createElement(d,r({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=u;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,r[1]=c;for(var s=2;s<a;s++)r[s]=n[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9796:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>c,toc:()=>s});var i=n(7462),o=(n(7294),n(3905));const a={sidebar_position:2},r="Tutorial 2: Time-Lock",c={unversionedId:"tutorials/timeLock",id:"tutorials/timeLock",title:"Tutorial 2: Time-Lock",description:"Overview",source:"@site/docs/tutorials/timeLock.md",sourceDirName:"tutorials",slug:"/tutorials/timeLock",permalink:"/tutorials/timeLock",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Tutorial 1: Hello World",permalink:"/tutorials/hello-world"},next:{title:"Tutorial 3: Auction",permalink:"/tutorials/auction"}},l={},s=[{value:"Overview",id:"overview",level:2},{value:"What is a time-lock?",id:"what-is-a-time-lock",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Contract properties",id:"contract-properties",level:2},{value:"The Time-Locked Public Method",id:"the-time-locked-public-method",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:s};function m(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,i.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"tutorial-2-time-lock"},"Tutorial 2: Time-Lock"),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"In this tutorial, we will go over how to create a smart contract, which has a public method, that can only be unlocked once a certain point in time has passed."),(0,o.kt)("h3",{id:"what-is-a-time-lock"},"What is a time-lock?"),(0,o.kt)("p",null,"In the context of smart contracts, a time-lock is a feature that restricts the spending of specific bitcoins until a specified future time or block height is reached. sCrypt offers capabilities to implement these types of time-locks in your smart contracts, providing a mechanism to ensure a transaction won't be included in a block before a certain point in time or block height is reached. In other words, the smart contract's method cannot be successfully invoked until that point in time has passed."),(0,o.kt)("p",null,"For instance, this mechanism could be used to add a withdrawal method to a smart contract. In the event of non-cooperation from other parties, an individual could retrieve their funds locked in the smart contract after some amount of time has passed. This approach is utilized in ",(0,o.kt)("a",{parentName:"p",href:"https://xiaohuiliu.medium.com/cross-chain-atomic-swaps-f13e874fcaa7"},"cross-chain atomic swaps"),", for example."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(4795).Z,width:"640",height:"320"}),"\n",(0,o.kt)("img",{src:n(3848).Z,width:"834",height:"418"}),"\n",(0,o.kt)("em",{parentName:"p"},"Image Credit: ",(0,o.kt)("a",{parentName:"em",href:"https://bcoin.io/guides/swaps.html"},"bcoin"))),(0,o.kt)("h3",{id:"implementation"},"Implementation"),(0,o.kt)("p",null,"In sCrypt, a time-lock can be enforced by constraining the ",(0,o.kt)("inlineCode",{parentName:"p"},"locktime")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sequence")," values of the ",(0,o.kt)("a",{parentName:"p",href:"../how-to-write-a-contract/scriptcontext"},"script execution context"),". This context pertains to the execution of the transaction, which includes a call to the smart contract's public method. Thus, if the value is constrained \u2013 for example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"locktime")," needs to be above the value ",(0,o.kt)("inlineCode",{parentName:"p"},"1690236000")," (a Unix timestamp) \u2013 then this transaction cannot be included into the blockchain until that point in time."),(0,o.kt)("p",null,"Note that the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"locktime")," can either be a Unix timestamp or a block height. For this value to be enforced, ",(0,o.kt)("inlineCode",{parentName:"p"},"sequence")," also needs to be set to a value less than ",(0,o.kt)("inlineCode",{parentName:"p"},"0xffffffff"),"."),(0,o.kt)("h2",{id:"contract-properties"},"Contract properties"),(0,o.kt)("p",null,"Let's declare the properties of our smart contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"static readonly LOCKTIME_BLOCK_HEIGHT_MARKER = 500000000\nstatic readonly UINT_MAX = 0xffffffffn\n\n// Time after which our public method can be called.\n@prop()\nreadonly matureTime: bigint // Can be a timestamp or block height.\n")),(0,o.kt)("h2",{id:"the-time-locked-public-method"},"The Time-Locked Public Method"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@method()\npublic unlock() {\n    // Ensure nSequence is less than UINT_MAX.\n    assert(\n        this.ctx.sequence < TimeLock.UINT_MAX,\n        'input sequence should less than UINT_MAX'\n    )\n\n    // Check if using block height.\n    if (\n        this.matureTime < TimeLock.LOCKTIME_BLOCK_HEIGHT_MARKER\n    ) {\n        // Enforce nLocktime field to also use block height.\n        assert(\n            this.ctx.locktime <\n                TimeLock.LOCKTIME_BLOCK_HEIGHT_MARKER,\n            'locktime should be less than 500000000'\n        )\n    }\n    assert(\n        this.ctx.locktime >= this.matureTime,\n        'locktime has not yet expired'\n    )\n}\n")),(0,o.kt)("p",null,"We can observe that our public method first asserts that the ",(0,o.kt)("inlineCode",{parentName:"p"},"sequence")," value of our calling transaction is less than ",(0,o.kt)("inlineCode",{parentName:"p"},"UINT_MAX"),". This ensures that the Bitcoin network will enforce the ",(0,o.kt)("inlineCode",{parentName:"p"},"locktime")," value."),(0,o.kt)("p",null,"Next, it checks if our target time-lock value indicates a block height or a Unix timestamp. If it's using a block height, i.e. the time-lock value is less than 500,000,000, the method also ensures that the ",(0,o.kt)("inlineCode",{parentName:"p"},"locktime")," value of the calling transaction corresponds to a block height."),(0,o.kt)("p",null,"Lastly, the method verifies that the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"locktime")," is greater than or equal to the time-lock we have set in the contract's property."),(0,o.kt)("p",null,"It is important to note that this mechanism can be employed solely to ensure that a method can be called ",(0,o.kt)("strong",{parentName:"p"},"after")," a specific point in time. In contrast, it cannot be employed to ensure that a method is called ",(0,o.kt)("strong",{parentName:"p"},"before")," a specific point in time. "),(0,o.kt)("p",null,"For more information on how the ",(0,o.kt)("inlineCode",{parentName:"p"},"locktime")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sequence")," values work, please read the ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.bitcoinsv.io/index.php/NLocktime_and_nSequence"},"BSV wiki page"),'."'),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Congratulations! You have completed the time-lock tutorial!"),(0,o.kt)("p",null,"The full code along with ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/tests/local/timeLock.test.ts"},"tests")," can be found in sCrypt's ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/timeLock.ts"},"boilerplate repository"),"."))}m.isMDXComponent=!0},4795:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/swap1-597f5664552aa55a2618d36c008f6e93.png"},3848:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/swap2-eb0d41670833d5dcc2aad196be3be44f.png"}}]);