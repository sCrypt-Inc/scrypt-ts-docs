"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[6325],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=l(n),m=a,h=u["".concat(c,".").concat(m)]||u[m]||d[m]||o;return n?r.createElement(h,s(s({ref:t},p),{},{components:n})):r.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6112:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_position:2},s="Non Fungible Tokens - NFTs",i={unversionedId:"tokens/nft/nft",id:"tokens/nft/nft",title:"Non Fungible Tokens - NFTs",description:"To create a smart contract that will carry an NFT, have your smart contract extend the OrdinalNFT class:",source:"@site/docs/tokens/nft/nft.md",sourceDirName:"tokens/nft",slug:"/tokens/nft/",permalink:"/tokens/nft/",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"The Official sCrypt 1Sat Ordinals SDK",permalink:"/tokens/"},next:{title:"Transfer Existing NFT to a Smart Contract",permalink:"/tokens/nft/existing"}},c={},l=[{value:"Inscribe",id:"inscribe",level:2},{value:"Transfer",id:"transfer",level:2}],p={toc:l};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"non-fungible-tokens---nfts"},"Non Fungible Tokens - NFTs"),(0,a.kt)("p",null,"To create a smart contract that will carry an NFT, have your smart contract extend the ",(0,a.kt)("inlineCode",{parentName:"p"},"OrdinalNFT")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { method, prop, assert, ByteString, sha256, Sha256 } from "scrypt-ts";\nimport { OrdinalNFT } from "scrypt-ord";\n\nexport class HashLockNFT extends OrdinalNFT {\n  @prop()\n  hash: Sha256;\n\n  constructor(hash: Sha256) {\n    super();\n    // Important: Call `init` after the `super()` statement.\n    this.init(...arguments);\n    this.hash = hash;\n  }\n\n  @method()\n  public unlock(message: ByteString) {\n    assert(this.hash === sha256(message), "hashes are not equal");\n  }\n}\n')),(0,a.kt)("p",null,"The contract above represents an NFT that can be unlocked / transferred by providing the secret pre-image of a hash value.\nEach constructor extending the ",(0,a.kt)("inlineCode",{parentName:"p"},"OrdinalNFT")," class must also call the instances ",(0,a.kt)("inlineCode",{parentName:"p"},"init")," method and pass the constructors arguments. It is important to call this function ",(0,a.kt)("strong",{parentName:"p"},"after")," the call to ",(0,a.kt)("inlineCode",{parentName:"p"},"super"),"."),(0,a.kt)("h2",{id:"inscribe"},"Inscribe"),(0,a.kt)("p",null,"The following code demonstrates how deploy / inscribe the NFT contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'HashLockNFT.loadArtifact();\n\nconst text = "Hello sCrypt and 1Sat Ordinals";\n\nconst message = toByteString(\'secret string\', true);\nconst hash = sha256(message);\n\nconst instance = new HashLockNFT(hash);\n\nconst signer = getDefaultSigner();\nawait instance.connect(signer);\n\nconst inscriptionTx = await instance.inscribeText(text);\nconsole.log("Inscribed NFT: ", inscriptionTx.id);\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"inscribeText")," first inscribes the locking script with the specified text and then deploys the contract."),(0,a.kt)("p",null,"Among text the inscription can contain many other types of data. Here's how you can conveniently inscribe an image:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'// ...\n\nconst bb = readFileSync(join(__dirname, "..", "..", "logo.png")).toString("base64");\n\nconst tx = await instance.inscribeImage(bb, ContentType.PNG);\nconsole.log("Inscribed NFT: ", tx.id);\n')),(0,a.kt)("p",null,"In fact the data type can be arbitrary. It only depends on the Ordinals wallet you're using to support that data type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const tx = await instance.inscribe({\n  content: `your content in hex`,\n  contentType: `your contentType`,\n});\nconsole.log("Inscribed NFT: ", tx.id);\n')),(0,a.kt)("p",null,"The value ",(0,a.kt)("inlineCode",{parentName:"p"},"contentType")," must be a MIME-type string. The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/scrypt-ord/blob/master/src/contentType.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"ContentType"))," object contains common MIME-types."),(0,a.kt)("h2",{id:"transfer"},"Transfer"),(0,a.kt)("p",null,"You can easily transfer a deployed NFT to an Ordinals address by passing a ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer")," value via the method call parameters. "),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"OrdiNFTP2PKH")," is a ",(0,a.kt)("a",{parentName:"p",href:"https://learnmeabitcoin.com/guide/p2pkh"},"P2PKH")," contract for holding ordinals NFTs. Like a normal P2PKH contract, you need an address to instantiate it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'// ... deploy code from above\n\nconst { tx: transferTx } = await instance.methods.unlock(\n    message, \n    {\n        transfer: new OrdiNFTP2PKH(\n                Addr(recipientAddress.toByteString())\n            ),\n    }\n);\n\nconsole.log("Transferred NFT: ", transferTx.id);\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer")," parameter can be any single instance of a contract that extends ",(0,a.kt)("inlineCode",{parentName:"p"},"OrdinalNFT"),"."))}d.isMDXComponent=!0}}]);