"use strict";(self.webpackChunkscrypt_ts_docs=self.webpackChunkscrypt_ts_docs||[]).push([[2731],{3905:(t,n,e)=>{e.d(n,{Zo:()=>p,kt:()=>m});var a=e(7294);function r(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function o(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,a)}return e}function l(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?o(Object(e),!0).forEach((function(n){r(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function i(t,n){if(null==t)return{};var e,a,r=function(t,n){if(null==t)return{};var e,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)e=o[a],n.indexOf(e)>=0||(r[e]=t[e]);return r}(t,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)e=o[a],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(r[e]=t[e])}return r}var c=a.createContext({}),s=function(t){var n=a.useContext(c),e=n;return t&&(e="function"==typeof t?t(n):l(l({},n),t)),e},p=function(t){var n=s(t.components);return a.createElement(c.Provider,{value:n},t.children)},u={inlineCode:"code",wrapper:function(t){var n=t.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(t,n){var e=t.components,r=t.mdxType,o=t.originalType,c=t.parentName,p=i(t,["components","mdxType","originalType","parentName"]),d=s(e),m=r,h=d["".concat(c,".").concat(m)]||d[m]||u[m]||o;return e?a.createElement(h,l(l({ref:n},p),{},{components:e})):a.createElement(h,l({ref:n},p))}));function m(t,n){var e=arguments,r=n&&n.mdxType;if("string"==typeof t||r){var o=e.length,l=new Array(o);l[0]=d;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=t,i.mdxType="string"==typeof t?t:r,l[1]=i;for(var s=2;s<o;s++)l[s]=e[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,e)}d.displayName="MDXCreateElement"},3558:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var a=e(7462),r=(e(7294),e(3905));const o={sidebar_position:12},l="Call Multiple Contracts in a Single Tx",i={unversionedId:"how-to-call-multiple-contracts",id:"how-to-call-multiple-contracts",title:"Call Multiple Contracts in a Single Tx",description:"Up to now, we have only shown how to call one smart contract in a transaction. That is, only one input of the tx spends a smart contract UTXO, and the other inputs, if any, spend Pay-to-Public-Key-Hash (P2PKH) UTXOs, which are generally NOT regarded as smart contracts.",source:"@site/docs/how-to-call-multiple-contracts.md",sourceDirName:".",slug:"/how-to-call-multiple-contracts",permalink:"/how-to-call-multiple-contracts",draft:!1,tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"How to Add a Signer",permalink:"/how-to-add-a-signer"},next:{title:"Tutorials",permalink:"/category/tutorials"}},c={},s=[],p={toc:s};function u(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,a.Z)({},p,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"call-multiple-contracts-in-a-single-tx"},"Call Multiple Contracts in a Single Tx"),(0,r.kt)("p",null,"Up to now, we have only shown how to call one smart contract in a transaction. That is, only one input of the tx spends a smart contract UTXO, and the other inputs, if any, spend Pay-to-Public-Key-Hash (",(0,r.kt)("a",{parentName:"p",href:"https://learnmeabitcoin.com/guide/p2pkh"},"P2PKH"),") UTXOs, which are generally NOT regarded as smart contracts."),(0,r.kt)("p",null,"There are cases where it is desirable to spend multiple smart contract UTXOs in different inputs of a tx."),(0,r.kt)("p",null,"The main differences from ",(0,r.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract#contract-call"},"calling a single contract")," are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"multiContractCall = true")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"MethodCallOptions")),(0,r.kt)("li",{parentName:"ol"},"Each call may only return a partial/incomplete transaction, instead of a complete transaction"),(0,r.kt)("li",{parentName:"ol"},"A partial tx has to be passed as ",(0,r.kt)("inlineCode",{parentName:"li"},"ContractTransaction")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"MethodCallOptions")," in subsequent calls"),(0,r.kt)("li",{parentName:"ol"},"Finally invoke ",(0,r.kt)("inlineCode",{parentName:"li"},"SmartContract.multiContractCall(partialContractTransaction: ContractTransaction, signer: Signer)")," to sign and broadcast the complete transaction")),(0,r.kt)("p",null,"The following is an ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/tests/testnet/multi_contracts_call.ts"},"example code")," of calling two contracts at the same time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import {\n    MethodCallOptions,\n    SmartContract,\n    bsv,\n    ContractTransaction,\n    toByteString,\n    sha256,\n} from 'scrypt-ts'\nimport { Counter } from '../../src/contracts/counter'\nimport { getDefaultSigner } from '../utils/helper'\nimport { HashPuzzle } from '../../src/contracts/hashPuzzle'\n\nasync function main() {\n    await Counter.compile()\n    await HashPuzzle.compile()\n\n    const signer = getDefaultSigner()\n    let counter = new Counter(1n)\n\n    // connect to a signer\n    await counter.connect(signer)\n\n    // contract deployment\n    const deployTx = await counter.deploy(1)\n    console.log('Counter contract deployed: ', deployTx.id)\n\n    counter.bindTxBuilder(\n        'incrementOnChain',\n        (\n            current: Counter,\n            options: MethodCallOptions<Counter>,\n            ...args: any\n        ): Promise<ContractTransaction> => {\n            // create the next instance from the current\n            const nextInstance = current.next()\n            // apply updates on the next instance locally\n            nextInstance.count++\n\n            const tx = new bsv.Transaction()\n            tx.addInput(current.buildContractInput(options.fromUTXO)).addOutput(\n                new bsv.Transaction.Output({\n                    script: nextInstance.lockingScript,\n                    satoshis: current.balance,\n                })\n            )\n\n            return Promise.resolve({\n                tx: tx,\n                atInputIndex: 0,\n                nexts: [\n                    {\n                        instance: nextInstance,\n                        balance: current.balance,\n                        atOutputIndex: 0,\n                    },\n                ],\n            })\n        }\n    )\n\n    const plainText = 'abc'\n    const byteString = toByteString(plainText, true)\n    const sha256Data = sha256(byteString)\n\n    const hashPuzzle = new HashPuzzle(sha256Data)\n\n    // connect to a signer\n    await hashPuzzle.connect(signer)\n\n    const deployTx1 = await hashPuzzle.deploy(1)\n    console.log('HashPuzzle contract deployed: ', deployTx1.id)\n\n    hashPuzzle.bindTxBuilder(\n        'unlock',\n        (\n            current: HashPuzzle,\n            options: MethodCallOptions<HashPuzzle>,\n            ...args: any\n        ): Promise<ContractTransaction> => {\n            if (options.partialContractTransaction) {\n                const unSignedTx = options.partialContractTransaction.tx\n                unSignedTx.addInput(\n                    current.buildContractInput(options.fromUTXO)\n                )\n\n                return Promise.resolve({\n                    tx: unSignedTx,\n                    atInputIndex: 1,\n                    nexts: [],\n                })\n            }\n\n            throw new Error('no partialContractTransaction found')\n        }\n    )\n\n    const partialContractTransaction1 = await counter.methods.incrementOnChain({\n        multiContractCall: true,\n    } as MethodCallOptions<Counter>)\n\n    const partialContractTransaction2 = await hashPuzzle.methods.unlock(\n        byteString,\n        {\n            multiContractCall: true,\n            partialContractTransaction: partialContractTransaction1,\n        } as MethodCallOptions<HashPuzzle>\n    )\n\n    const { tx: callTx, nexts } = await SmartContract.multiContractCall(\n        partialContractTransaction2,\n        signer\n    )\n\n    console.log('Counter, HashPuzzle contract `unlock` called: ', callTx.id)\n\n    // hashPuzzle has terminated, but counter can still be called\n    counter = nexts[0].instance\n}\n\ndescribe('Test SmartContract `Counter, HashPuzzle ` multi called on testnet', () => {\n    it('should succeed', async () => {\n        await main()\n    })\n})\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"You must bind a ",(0,r.kt)("a",{parentName:"li",href:"./how-to-deploy-and-call-a-contract#tx-builders"},"transition builder")," to each contract instance, since ",(0,r.kt)("a",{parentName:"li",href:"/how-to-customize-a-contract-tx#customize-1"},"the default")," only spends a single contract UTXO."),(0,r.kt)("li",{parentName:"ul"},"If the called contracts need signatures from different private keys to be called, the signer passed to ",(0,r.kt)("inlineCode",{parentName:"li"},"multiContractCall")," must have all private keys."))))}u.isMDXComponent=!0}}]);