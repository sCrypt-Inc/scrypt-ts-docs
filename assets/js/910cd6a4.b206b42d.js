"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[2],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=a,h=d["".concat(c,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(h,i(i({ref:t},u),{},{components:n})):r.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2728:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const o={title:"Transfer Existing FT to a Smart Contract",sidebar_position:1},i=void 0,s={unversionedId:"tokens/ft/existing",id:"tokens/ft/existing",title:"Transfer Existing FT to a Smart Contract",description:"Suppose you'd like to unlock existing UTXOs that carry a FT to a smart contract.",source:"@site/docs/tokens/ft/existing.md",sourceDirName:"tokens/ft",slug:"/tokens/ft/existing",permalink:"/tokens/ft/existing",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Transfer Existing FT to a Smart Contract",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Funglible Tokens - FTs",permalink:"/tokens/ft/"},next:{title:"Multiple Inputs with Different Contracts",permalink:"/tokens/ft/multiple"}},c={},l=[{value:"Handling Change",id:"handling-change",level:2}],u={toc:l};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Suppose you'd like to unlock existing UTXOs that carry a FT to a smart contract."),(0,a.kt)("p",null,"If you would like to unlock a single specific UTXO, you can do the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"HashLockFT.loadArtifact();\n...\n// Initialize recipient smart contract.\nconst message = toByteString('super secret', true);\nconst hash = sha256(message);\nconst recipient = new HashLockFT(tick, max, lim, dec, hash);\nawait recipient.connect(getDefaultSigner());\n\n// Create P2PKH object from an UTXO\n// NOTE: You can not use BSV20V2P2PKH.getLatestInstance for BSV-20, it only works for NFTs.\nconst utxo: UTXO = ...\nconst p2pkh = BSV20V2P2PKH.fromUTXO(utxo);\nawait p2pkh.connect(getDefaultSigner());\n\n// Unlock it and transfer the FTs carried by it.\nconst { tx: transferTx } = await p2pkh.methods.unlock(\n  (sigResps) => findSig(sigResps, `yourPubKey`),\n  PubKey(`yourPubKey`.toByteString()),\n  {\n    transfer: recipient,\n    pubKeyOrAddrToSign: `yourPubKey`,\n  } as OrdiMethodCallOptions<BSV20V2P2PKH>\n);\n\nconsole.log(\"Transferred FT: \", transferTx.id);\n")),(0,a.kt)("p",null,"Alternatively, you can unlock multiple FT UTXOs and send them to a smart contract. Using the ",(0,a.kt)("inlineCode",{parentName:"p"},"getBSV20")," function you can simply fetch FT UTXOs for a given Ordinal wallet address."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'// ... initialize recipient smart contract\n\n// Fetch FT UTXOs for given Ordinal address.\n// NOTE: You can not use BSV20V2P2PKH.getLatestInstance for BSV-20, it only works for NFTs.\nconst bsv20P2PKHs = await BSV20V2P2PKH.getBSV20(tokenId, `your ordinal address`);\n\nawait Promise.all(bsv20P2PKHs.map((p) => p.connect(signer)));\n\n// Construct recipient smart contract(s)\nconst recipients: Array<FTReceiver> = [\n  {\n    instance: new HashLockFTV2(tokenId, amount, dec, sha256(message)),\n    amt: 6n,\n  },\n];\n\n// Transfer\nconst { tx, nexts } = await BSV20V2P2PKH.transfer(\n  bsv20P2PKHs,\n  signer,\n  recipients\n);\n\nconsole.log("Transferred FT: ", transferTx.id);\n')),(0,a.kt)("h2",{id:"handling-change"},"Handling Change"),(0,a.kt)("p",null,"Note, how the mechanism above is very similar to a regular Bitcoin transfer. If the FT amount from the inputs exceeds the recipients amount, the leftover will be transferred back to the Ordinal address as change."),(0,a.kt)("p",null,"You can customize the address using the method call option ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenChangeAddress"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const { tx: transferTx } = await p2pkh.methods.unlock(\n  (sigResps) => findSig(sigResps, `yourPubKey`),\n  PubKey(`yourPubKey`.toByteString()),\n  {\n    transfer: recipient,\n    pubKeyOrAddrToSign: `yourPubKey`,\n    tokenChangeAddress: yourOrdinalAddress\n  } as OrdiMethodCallOptions<BSV20V2P2PKH>\n)\n")),(0,a.kt)("p",null,"You can also skip change altogether by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"skipTokenChange")," option. But be careful! Any leftover tokens will be considered ",(0,a.kt)("strong",{parentName:"p"},"burned")," in this case:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const { tx: transferTx } = await p2pkh.methods.unlock(\n  (sigResps) => findSig(sigResps, `yourPubKey`),\n  PubKey(`yourPubKey`.toByteString()),\n  {\n    transfer: recipient,\n    pubKeyOrAddrToSign: `yourPubKey`,\n    skipTokenChange: true\n  } as OrdiMethodCallOptions<BSV20V2P2PKH>\n)\n")),(0,a.kt)("h1",{id:"buildstateoutputft"},(0,a.kt)("inlineCode",{parentName:"h1"},"buildStateOutputFT")),(0,a.kt)("p",null,"Any instance of ",(0,a.kt)("inlineCode",{parentName:"p"},"BSV20V1")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"BSV20V2")," contains the ",(0,a.kt)("inlineCode",{parentName:"p"},"buildStateOutputFT")," method. Unlike the regular ",(0,a.kt)("inlineCode",{parentName:"p"},"buildStateOutput")," method, this method inscribes the subsequent amount with an appropriate ",(0,a.kt)("a",{parentName:"p",href:"https://docs.1satordinals.com/bsv20#transfer-all-modes"},"BSV-20 transfer inscription"),". The method takes the number of tokens to be transferred to the subsequent output as an argument."),(0,a.kt)("p",null,"Below is an example of an FT counter contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class CounterFTV2 extends BSV20V2 {\n\n    @prop(true)\n    counter: bigint\n\n    constructor(id: ByteString, max: bigint, dec: bigint, counter: bigint) {\n        super(id, max, dec)\n        this.init(...arguments)\n        this.counter = counter\n    }\n\n    @method(SigHash.ANYONECANPAY_SINGLE)\n    public inc(tokenAmt: bigint) {\n        this.counter++\n\n        const outputs = this.buildStateOutputFT(tokenAmt)\n\n        assert(\n            this.ctx.hashOutputs == hash256(outputs),\n            'hashOutputs check failed'\n        )\n    }\n\n}\n")),(0,a.kt)("p",null,"Each iteration will contain the number of tokens that was passed via ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenAmt"),". Note that this amount cannot be larger than the amount in the previous iteration. If the amount is less than in the previous iteration, the remaining tokens will be returned as change."))}p.isMDXComponent=!0}}]);