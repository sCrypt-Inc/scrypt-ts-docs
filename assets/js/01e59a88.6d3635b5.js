"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[7738],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=p(n),d=i,m=h["".concat(s,".").concat(d)]||h[d]||c[d]||o;return n?a.createElement(m,r(r({ref:t},u),{},{components:n})):a.createElement(m,r({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3553:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:5},r="Tutorial 5: Tic Tac Toe",l={unversionedId:"tutorials/tic-tac-toe",id:"tutorials/tic-tac-toe",title:"Tutorial 5: Tic Tac Toe",description:"Overview",source:"@site/docs/tutorials/tic-tac-toe.md",sourceDirName:"tutorials",slug:"/tutorials/tic-tac-toe",permalink:"/tutorials/tic-tac-toe",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Tutorial 4: Oracle",permalink:"/tutorials/oracle"},next:{title:"Tutorial 6: Zero Knowledge Proofs",permalink:"/tutorials/zkp"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"Contract Properties",id:"contract-properties",level:2},{value:"Constructor",id:"constructor",level:2},{value:"Public Methods",id:"public-methods",level:2},{value:"Signature Verification",id:"signature-verification",level:3},{value:"Non-Public Methods",id:"non-public-methods",level:2},{value:"Maintain Game State",id:"maintain-game-state",level:2},{value:"Step 1",id:"step-1",level:3},{value:"Step 2",id:"step-2",level:3},{value:"Build outputs in public <code>@method</code>",id:"build-outputs-in-public-method",level:4},{value:"Step 3",id:"step-3",level:3}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tutorial-5-tic-tac-toe"},"Tutorial 5: Tic Tac Toe"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"In this tutorial, we will go over how to use sCrypt to build a Tic-Tac-Toe Contract on Bitcoin."),(0,i.kt)("p",null,"It is initialized with the Bitcoin public key of two players (Alice and Bob respectively). They each bet the same amount and lock it into the contract. The winner takes all bitcoins locked in the contract. If no one wins and there is a draw, the two players can each withdraw half of the money."),(0,i.kt)("h2",{id:"contract-properties"},"Contract Properties"),(0,i.kt)("p",null,"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop")," decorator to mark any property that intends to be stored on chain. This decorator accepts a boolean parameter. By default, it is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", meaning the property cannot be changed after the contract is deployed. If it is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the property is a so-called ",(0,i.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/stateful-contract"},"stateful")," property and its value can be updated in subsequent contract calls."),(0,i.kt)("p",null,"The tic-tac-toe contract supports two players and their public keys need to be saved. It contains the following contract properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Two stateless properties ",(0,i.kt)("inlineCode",{parentName:"li"},"alice")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"bob"),", both of which are ",(0,i.kt)("inlineCode",{parentName:"li"},"PubKey")," type."),(0,i.kt)("li",{parentName:"ul"},"Two stateful properties:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_alice_turn"),": a ",(0,i.kt)("inlineCode",{parentName:"li"},"boolean"),". It represents whether it is ",(0,i.kt)("inlineCode",{parentName:"li"},"alice"),"'s turn to play."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"board"),": a fixed-size array ",(0,i.kt)("inlineCode",{parentName:"li"},"FixedArray<bigint, 9>")," with a size of ",(0,i.kt)("inlineCode",{parentName:"li"},"9"),". It represents the state of every square in the board."))),(0,i.kt)("li",{parentName:"ul"},"Three constants:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"EMPTY"),", type ",(0,i.kt)("inlineCode",{parentName:"li"},"bigint"),", value ",(0,i.kt)("inlineCode",{parentName:"li"},"0n"),". It means that a square in the board is empty"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ALICE"),", type ",(0,i.kt)("inlineCode",{parentName:"li"},"bigint"),", value ",(0,i.kt)("inlineCode",{parentName:"li"},"1n"),". Alice places symbol ",(0,i.kt)("inlineCode",{parentName:"li"},"X")," in a square."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"BOB"),", type ",(0,i.kt)("inlineCode",{parentName:"li"},"bigint"),", value ",(0,i.kt)("inlineCode",{parentName:"li"},"2n"),". Bob places symbol ",(0,i.kt)("inlineCode",{parentName:"li"},"O")," in a square.")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@prop()\nalice: PubKey; // alice's public Key\n@prop()\nbob: PubKey; // bob's public Key\n\n@prop(true)\nis_alice_turn: boolean; // stateful property, it represents whether it is `alice`'s turn to play.\n\n@prop(true)\nboard: FixedArray<bigint, 9>; // stateful property, a fixed-size array, it represents the state of every square in the board.\n\n@prop()\nstatic readonly EMPTY: bigint = 0n; // static property, it means that the a square in the board is empty\n@prop()\nstatic readonly ALICE: bigint = 1n; // static property, it means that alice places symbol `X` in a square.\n@prop()\nstatic readonly BOB: bigint = 2n; // static property, it means that bob places symbol `O` in a square.\n")),(0,i.kt)("h2",{id:"constructor"},"Constructor"),(0,i.kt)("p",null,"Initialize all non-static properties in the constructor. Specifically, the entire board is empty at first."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"constructor(alice: PubKey, bob: PubKey) {\n    super(...arguments);\n    this.alice = alice;\n    this.bob = bob;\n    this.is_alice_turn = true;\n    this.board = fill(TicTacToe.EMPTY, 9);\n}\n")),(0,i.kt)("h2",{id:"public-methods"},"Public Methods"),(0,i.kt)("p",null,"A public ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," can be called from an external transaction. The call succeeds if it runs to completion without violating any conditions in ",(0,i.kt)("inlineCode",{parentName:"p"},"assert()"),". "),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TicTacToe")," contract have a public ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," called ",(0,i.kt)("inlineCode",{parentName:"p"},"move()")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * play the game by calling move()\n * @param n which square to place the symbol\n * @param sig a player's signature\n */\n@method()\npublic move(n: bigint, sig: Sig) {\n    assert(n >= 0n && n < 9n);\n}\n")),(0,i.kt)("p",null,"Alice and Bob each locks X bitcoins in a UTXO containing contract ",(0,i.kt)("inlineCode",{parentName:"p"},"TicTacToe"),". Next, they alternately play the game by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"move()"),"."),(0,i.kt)("h3",{id:"signature-verification"},"Signature Verification"),(0,i.kt)("p",null,"Once the game contract is deployed, anyone can view and potentially interact with it. We need a authentication mechanism to ensure only the desired player can update the contract if it's their turn. This is achieved using ditigal signatures."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"this.checkSig()")," is used to verify a signature against a public key. Use it to verify the ",(0,i.kt)("inlineCode",{parentName:"p"},"sig")," parameter against the desired player in ",(0,i.kt)("inlineCode",{parentName:"p"},"move()"),", identified by their public key stored in the contract's properties."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// check signature `sig`\nlet player: PubKey = this.is_alice_turn ? this.alice : this.bob;\nassert(this.checkSig(sig, player), `checkSig failed, pubkey: ${player}`);\n")),(0,i.kt)("h2",{id:"non-public-methods"},"Non-Public Methods"),(0,i.kt)("p",null,"Without a ",(0,i.kt)("inlineCode",{parentName:"p"},"public")," modifier, a ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," is internal and cannot be directly called from an external transaction."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TicTacToe")," contract have two ",(0,i.kt)("strong",{parentName:"p"},"Non-Public")," methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"won()")," : iterate over the ",(0,i.kt)("inlineCode",{parentName:"li"},"lines")," array to check if a player has won the game. returns ",(0,i.kt)("inlineCode",{parentName:"li"},"boolean")," type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"full()")," : traverse all the squares of the board to check if all squares of the board have symbols. returns ",(0,i.kt)("inlineCode",{parentName:"li"},"boolean")," type.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@method()\nwon(play: bigint) : boolean {\n    let lines: FixedArray<FixedArray<bigint, 3>, 8> = [\n        [0n, 1n, 2n],\n        [3n, 4n, 5n],\n        [6n, 7n, 8n],\n        [0n, 3n, 6n],\n        [1n, 4n, 7n],\n        [2n, 5n, 8n],\n        [0n, 4n, 8n],\n        [2n, 4n, 6n]\n    ];\n\n    let anyLine = false;\n\n    for (let i = 0; i < 8; i++) {\n        let line = true;\n        for (let j = 0; j < 3; j++) {\n            line = line && this.board[Number(lines[i][j])] === play;\n        }\n\n        anyLine = anyLine || line;\n    }\n\n    return anyLine;\n}\n\n@method()\nfull() : boolean {\n    let full = true;\n    for (let i = 0; i < 9; i++) {\n        full = full && this.board[i] !== TicTacToe.EMPTY;\n    }\n    return full;\n}\n")),(0,i.kt)("h2",{id:"maintain-game-state"},"Maintain Game State"),(0,i.kt)("p",null,"We can directly access the ",(0,i.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/scriptcontext"},"ScriptContext")," through ",(0,i.kt)("inlineCode",{parentName:"p"},"this.ctx")," in the public ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," ",(0,i.kt)("inlineCode",{parentName:"p"},"move()")," to maintain game state. It can be considered additional information a public method gets when called, besides its function parameters."),(0,i.kt)("p",null,"Contract maintenance state consists of the following three steps:"),(0,i.kt)("h3",{id:"step-1"},"Step 1"),(0,i.kt)("p",null,"Update the stateful properties in public ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"."),(0,i.kt)("p",null,"A player call ",(0,i.kt)("inlineCode",{parentName:"p"},"move()")," to places the symbol in the board. We should update the stateful properties ",(0,i.kt)("inlineCode",{parentName:"p"},"board")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"is_alice_turn")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"move()")," ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),": "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"assert(this.board[Number(n)] === TicTacToe.EMPTY, `board at position ${n} is not empty: ${this.board[Number(n)]}`);\nlet play = this.is_alice_turn ? TicTacToe.ALICE : TicTacToe.BOB;\n// update stateful properties to make the move\nthis.board[Number(n)] = play;   // Number() converts a bigint to a number\nthis.is_alice_turn = !this.is_alice_turn;\n")),(0,i.kt)("h3",{id:"step-2"},"Step 2"),(0,i.kt)("p",null,"When you are ready to pass the new state onto the output","[s]"," in the current spending transaction, simply call a built-in function ",(0,i.kt)("inlineCode",{parentName:"p"},"this.buildStateOutput()")," to create an output containing the new state. It takes an input: the number of satoshis in the output. We keep the satoshis unchanged in the example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let output = this.buildStateOutput(this.ctx.utxo.value);\n")),(0,i.kt)("h4",{id:"build-outputs-in-public-method"},"Build outputs in public ",(0,i.kt)("inlineCode",{parentName:"h4"},"@method")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"TicTacToe")," can contain the following three types of output during execution:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The game is not over: a output containing the new state and a change output"),(0,i.kt)("li",{parentName:"ol"},"A player wins the game: a ",(0,i.kt)("inlineCode",{parentName:"li"},"P2PKH")," output that pays the winner, and a change output."),(0,i.kt)("li",{parentName:"ol"},"A draw: two ",(0,i.kt)("inlineCode",{parentName:"li"},"P2PKH")," outputs that split the contract-locked bets equally between the players and a change output.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"P2PKH")," output can be built using ",(0,i.kt)("inlineCode",{parentName:"p"},"Utils.buildPublicKeyHashOutput(pkh: PubKeyHash, amount: bigint)"),". The ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.bitcoinsv.io/index.php/Change"},"change output")," can be built using ",(0,i.kt)("inlineCode",{parentName:"p"},"this.buildChangeOutput()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// build the transation outputs\nlet outputs = toByteString('');\nif (this.won(play)) {\n    outputs = Utils.buildPublicKeyHashOutput(hash160(player), this.ctx.utxo.value);\n}\nelse if (this.full()) {\n    const halfAmount = this.ctx.utxo.value / 2n;\n    const aliceOutput = Utils.buildPublicKeyHashOutput(hash160(this.alice), halfAmount);\n    const bobOutput = Utils.buildPublicKeyHashOutput(hash160(this.bob), halfAmount);\n    outputs = aliceOutput + bobOutput;\n}\nelse {\n    // build a output that contains latest contract state.\n    outputs = this.buildStateOutput(this.ctx.utxo.value);\n}\n\noutputs += this.buildChangeOutput();\n\n")),(0,i.kt)("h3",{id:"step-3"},"Step 3"),(0,i.kt)("p",null,"Make sure that the output of the current transaction must contain this incremented new state. If all outputs (only a single output here) we create in the contract hashes to ",(0,i.kt)("inlineCode",{parentName:"p"},"hashOutputs")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"ScriptContext"),", we can be sure they are the outputs of the current transaction. Therefore, the updated state is propagated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// verify current tx has this single output\nassert(this.ctx.hashOutputs == hash256(outputs), 'hashOutputs mismatch')\n")),(0,i.kt)("h1",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Congratulations, you have completed the ",(0,i.kt)("inlineCode",{parentName:"p"},"TicTacToe")," contract!"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/tic-tac-toe/blob/f098108b11e54428f37e2814992ca9f4385a89de/src/contracts/tictactoe.ts"},"final complete code")," is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export class TicTacToe extends SmartContract {\n    @prop()\n    alice: PubKey;\n    @prop()\n    bob: PubKey;\n\n    @prop(true)\n    is_alice_turn: boolean;\n\n    @prop(true)\n    board: FixedArray<bigint, 9>;\n\n    @prop()\n    static readonly EMPTY: bigint = 0n;\n    @prop()\n    static readonly ALICE: bigint = 1n;\n    @prop()\n    static readonly BOB: bigint = 2n;\n\n    constructor(alice: PubKey, bob: PubKey) {\n        super(...arguments)\n        this.alice = alice;\n        this.bob = bob;\n        this.is_alice_turn = true;\n        this.board = fill(TicTacToe.EMPTY, 9);\n    }\n\n    @method()\n    public move(n: bigint, sig: Sig) {\n        // check position `n`\n        assert(n >= 0n && n < 9n);\n        // check signature `sig`\n        let player: PubKey = this.is_alice_turn ? this.alice : this.bob;\n        assert(this.checkSig(sig, player), `checkSig failed, pubkey: ${player}`);\n        // update stateful properties to make the move\n        assert(this.board[Number(n)] === TicTacToe.EMPTY, `board at position ${n} is not empty: ${this.board[Number(n)]}`);\n        let play = this.is_alice_turn ? TicTacToe.ALICE : TicTacToe.BOB;\n        this.board[Number(n)] = play;\n        this.is_alice_turn = !this.is_alice_turn;\n\n        // build the transation outputs\n        let outputs = toByteString('');\n        if (this.won(play)) {\n            outputs = Utils.buildPublicKeyHashOutput(hash160(player), this.ctx.utxo.value);\n        }\n        else if (this.full()) {\n            const halfAmount = this.ctx.utxo.value / 2n;\n            const aliceOutput = Utils.buildPublicKeyHashOutput(hash160(this.alice), halfAmount);\n            const bobOutput = Utils.buildPublicKeyHashOutput(hash160(this.bob), halfAmount);\n            outputs = aliceOutput + bobOutput;\n        }\n        else {\n            // build a output that contains latest contract state.\n            outputs = this.buildStateOutput(this.ctx.utxo.value);\n        }\n\n        outputs += this.buildChangeOutput();\n\n        // make sure the transaction contains the expected outputs built above\n        assert(this.ctx.hashOutputs === hash256(outputs), \"check hashOutputs failed\");\n    }\n\n    @method()\n    won(play: bigint): boolean {\n        let lines: FixedArray<FixedArray<bigint, 3>, 8> = [\n            [0n, 1n, 2n],\n            [3n, 4n, 5n],\n            [6n, 7n, 8n],\n            [0n, 3n, 6n],\n            [1n, 4n, 7n],\n            [2n, 5n, 8n],\n            [0n, 4n, 8n],\n            [2n, 4n, 6n]\n        ];\n\n        let anyLine = false;\n\n        for (let i = 0; i < 8; i++) {\n            let line = true;\n            for (let j = 0; j < 3; j++) {\n                line = line && this.board[Number(lines[i][j])] === play;\n            }\n\n            anyLine = anyLine || line;\n        }\n\n        return anyLine;\n    }\n\n    @method()\n    full(): boolean {\n        let full = true;\n        for (let i = 0; i < 9; i++) {\n            full = full && this.board[i] !== TicTacToe.EMPTY;\n        }\n        return full;\n    }\n\n}\n\n")),(0,i.kt)("p",null,"But no dApp is complete if users cannot interact with it. Go ",(0,i.kt)("a",{parentName:"p",href:"/how-to-integrate-a-frontend/"},"here")," to see how to add a front end to it."))}c.isMDXComponent=!0}}]);