"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[6297],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>d});var a=n(7294);function s(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){s(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function r(t,e){if(null==t)return{};var n,a,s=function(t,e){if(null==t)return{};var n,a,s={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(s[n]=t[n]);return s}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(s[n]=t[n])}return s}var c=a.createContext({}),l=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},u=function(t){var e=l(t.components);return a.createElement(c.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},h=a.forwardRef((function(t,e){var n=t.components,s=t.mdxType,i=t.originalType,c=t.parentName,u=r(t,["components","mdxType","originalType","parentName"]),h=l(n),d=s,m=h["".concat(c,".").concat(d)]||h[d]||p[d]||i;return n?a.createElement(m,o(o({ref:e},u),{},{components:n})):a.createElement(m,o({ref:e},u))}));function d(t,e){var n=arguments,s=e&&e.mdxType;if("string"==typeof t||s){var i=n.length,o=new Array(i);o[0]=h;var r={};for(var c in e)hasOwnProperty.call(e,c)&&(r[c]=e[c]);r.originalType=t,r.mdxType="string"==typeof t?t:s,o[1]=r;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4343:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var a=n(7462),s=(n(7294),n(3905));const i={sidebar_position:3},o="Stateful Contracts",r={unversionedId:"how-to-write-a-contract/stateful-contract",id:"how-to-write-a-contract/stateful-contract",title:"Stateful Contracts",description:"Overview",source:"@site/docs/how-to-write-a-contract/stateful-contract.md",sourceDirName:"how-to-write-a-contract",slug:"/how-to-write-a-contract/stateful-contract",permalink:"/how-to-write-a-contract/stateful-contract",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"ScriptContext",permalink:"/how-to-write-a-contract/scriptcontext"},next:{title:"Built-ins",permalink:"/how-to-write-a-contract/built-ins"}},c={},l=[{value:"Overview",id:"overview",level:2},{value:"Create a Stateful Contract",id:"create-a-stateful-contract",level:2},{value:"Stateful properties",id:"stateful-properties",level:3},{value:"Update states",id:"update-states",level:3},{value:"Stateless vs Stateful Contracts",id:"stateless-vs-stateful-contracts",level:2},{value:"Stateless Multi-Sig",id:"stateless-multi-sig",level:3},{value:"Stateful Multi-Sig",id:"stateful-multi-sig",level:3}],u={toc:l};function p(t){let{components:e,...i}=t;return(0,s.kt)("wrapper",(0,a.Z)({},u,i,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"stateful-contracts"},"Stateful Contracts"),(0,s.kt)("h2",{id:"overview"},"Overview"),(0,s.kt)("p",null,"In Bitcoin's UTXO model, a smart contract is one-off and ",(0,s.kt)("strong",{parentName:"p"},"stateless")," by default, since the UTXO containing it is destroyed after being spent. Being stateless allows it to scale easily, the same as in ",(0,s.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/5836881/stateless-protocol-and-stateful-protocol"},"HTTP")," and ",(0,s.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/restful-statelessness/"},"REST APIs"),".\nA smart contract can simulate state by requiring\nthe output of the spending transaction containing the same contract but with the updated state, enabled by ",(0,s.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/scriptcontext"},"ScriptContext"),".\nThis is similar to making HTTP seem stateful by using cookies."),(0,s.kt)("p",null,"So far, all the contracts we\u2019ve gone through have been stateless. But often, you may want a contract to have some concept of \u201cmemory\u201d so that it may remember information about its previous interactions. That is, we need contracts that are ",(0,s.kt)("strong",{parentName:"p"},"stateful"),"."),(0,s.kt)("p",null,"To achieve that, we divide a smart contract in the locking script of an output into two parts: code and state as shown below. The code part contains the business logic of a contract that encodes rules for state transition and must ",(0,s.kt)("strong",{parentName:"p"},"NOT")," change. State transition occurs when a transaction spends the output containing the old state and creates a new output containing the new state, while keeping the contract code intact.\nSince the new output contains the same contract code, its spending transaction must also retain the same code, otherwise it will fail. This chain of transactions can go on and on and thus a state is maintained along the chain, recursively.\n",(0,s.kt)("img",{src:n(4700).Z,width:"2704",height:"774"})),(0,s.kt)("h2",{id:"create-a-stateful-contract"},"Create a Stateful Contract"),(0,s.kt)("p",null,"We can create a stateful contract using the following command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sh"},"scrypt project --state my-project\n")),(0,s.kt)("p",null,"Note the ",(0,s.kt)("inlineCode",{parentName:"p"},"state")," option is turned on."),(0,s.kt)("p",null,"This will create a project containing a sample stateful contract named ",(0,s.kt)("inlineCode",{parentName:"p"},"Counter"),". This contract maintains a single state: how many times it has been called since deployment."),(0,s.kt)("p",null,"Let's take a look at the contract source file ",(0,s.kt)("inlineCode",{parentName:"p"},"src/contracts/counter.ts"),"."),(0,s.kt)("h3",{id:"stateful-properties"},"Stateful properties"),(0,s.kt)("p",null,"As shown ",(0,s.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/#properties"},"before"),", a ",(0,s.kt)("inlineCode",{parentName:"p"},"@prop(true)")," decorator is used to make a property part of the contract state, meaning it can be mutated when the contract gets called."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"@prop(true)\ncount: bigint\n")),(0,s.kt)("h3",{id:"update-states"},"Update states"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"incrementOnChain()")," method does two things:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Call ",(0,s.kt)("inlineCode",{parentName:"li"},"increment")," to update the state:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"@method()\nincrement(): void {\n    this.count++\n}\n")),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Validate the new state goes into the next UTXO containing the same contract, i.e., the state is maintained.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// make sure balance in the contract does not change\nconst amount: bigint = this.ctx.utxo.value\n// output containing the latest state\nconst output: ByteString = this.buildStateOutput(amount)\n// verify current tx has this single output\nassert(this.ctx.hashOutputs == hash256(output), 'hashOutputs mismatch')\n")),(0,s.kt)("p",null,"The built-in function ",(0,s.kt)("inlineCode",{parentName:"p"},"this.buildStateOutput()")," creates an output containing the latest state. It takes an input: the number of satoshis in the output. We keep the satoshis unchanged in the example. If all outputs (only a single output here) we create in the contract hashes to ",(0,s.kt)("inlineCode",{parentName:"p"},"hashOutputs")," in ",(0,s.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/scriptcontext"},"ScriptContext"),", we can be sure they are the outputs of the current transaction. Therefore, the updated state is propagated."),(0,s.kt)("p",null,"The complete stateful contract is as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export class Counter extends SmartContract {\n  // stateful\n  @prop(true)\n  count: bigint\n\n  constructor(count: bigint) {\n    super(...arguments)\n    this.count = count\n  }\n\n  @method(SigHash.ANYONECANPAY_SINGLE)\n  public incrementOnChain() {\n    this.increment()\n\n    // make sure balance in the contract does not change\n    const amount: bigint = this.ctx.utxo.value\n    // output containing the latest state\n    const output: ByteString = this.buildStateOutput(amount)\n    // verify current tx has this single output\n    assert(this.ctx.hashOutputs == hash256(output), 'hashOutputs mismatch')\n  }\n\n  @method()\n  increment(): void {\n      this.count++\n  }\n}\n")),(0,s.kt)("h2",{id:"stateless-vs-stateful-contracts"},"Stateless vs Stateful Contracts"),(0,s.kt)("p",null,"The choice between stateless and stateful smart contracts hinges on the needs of your blockchain application."),(0,s.kt)("p",null,"If your application involves complex operations where persistent data is required, a stateful smart contract may be more appropriate. Examples include applications that track balances or ownership, like ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/erc20.ts"},"tokens")," or ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/tic-tac-toe/blob/main/src/contracts/tictactoe.ts"},"whole games"),"."),(0,s.kt)("p",null,"On the other hand, if your application merely needs to execute simple transactions without retaining data, a stateless smart contract might be a more efficient choice. An example would be a simple transfer, such as a ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/hashPuzzle.ts"},"hash puzzle"),"."),(0,s.kt)("p",null,"Let's explore an example where using a stateful contract comes useful. We will compare two ways to implement a multi-sig smart contract. One is implemented stateless, the other one is stateful."),(0,s.kt)("h3",{id:"stateless-multi-sig"},"Stateless Multi-Sig"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class MultiSigPayment extends SmartContract {\n    // Public key hashes of the 3 signers.\n    @prop()\n    readonly pubKeyHashes: FixedArray<PubKeyHash, 3>\n\n    constructor(pubKeyHashes: FixedArray<PubKeyHash, 3>) {\n        super(...arguments)\n        this.pubKeyHashes = pubKeyHashes\n    }\n\n    @method()\n    public unlock(\n        signatures: FixedArray<Sig, 3>,\n        publicKeys: FixedArray<PubKey, 3>\n    ) {\n        // Check if the passed public keys belong to the specified public key hashes.\n        for (let i = 0; i < 3; i++) {\n            assert(\n                hash160(publicKeys[i]) == this.pubKeyHashes[i],\n                'public key hash mismatch'\n            )\n        }\n\n        // Validate signatures.\n        assert(\n            this.checkMultiSig(signatures, publicKeys),\n            'checkMultiSig failed'\n        )\n    }\n}\n")),(0,s.kt)("p",null,"The above is a stateless implementation of a multi-sig sCrypt smart contract. It must be unlocked within a single contract call (i.e. a single transaction) which needs to contain the needed signatures.\nSigners need to coordinate off-chain to construct the unlocking transaction, which includes agreeing upon the destination of the unlocked funds and signing the transaction."),(0,s.kt)("h3",{id:"stateful-multi-sig"},"Stateful Multi-Sig"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export type Owner = {\n    pubKey: PubKey\n    validated: boolean\n}\n\nexport class StatefulMultiSig extends SmartContract {\n    // Payment destination once signature threshold is reached.\n    @prop()\n    dest: PubKeyHash\n\n    // Public keys of the owners along with boolean flags, that\n    // indicate if their sig was already validated.\n    @prop(true)\n    owners: FixedArray<Owner, 3>\n\n    constructor(\n        dest: PubKeyHash,\n        owners: FixedArray<Owner, 3>\n    ) {\n        super(...arguments)\n        this.dest = dest\n        this.owners = owners\n    }\n    \n    \n    @method(SigHash.ANYONECANPAY_SINGLE)\n    public add(sig: Sig, pubKeyIdx: bigint) {\n        let added = false\n\n        for (let i = 0; i < 3; i++) {\n            if (BigInt(i) == pubKeyIdx) {\n                const owner = this.owners[i]\n                const valid = this.checkSig(sig, owner.pubKey)\n                if (valid && !owner.validated) {\n                    // Toggle flag.\n                    this.owners[i].validated = true\n                    added = true\n                }\n            }\n        }\n\n        // Make sure at least one new valid sig was added.\n        assert(added, 'No new valid signature was provided.')\n\n        // Make sure balance in the contract does not change.\n        const amount: bigint = this.ctx.utxo.value\n        // Output containing the latest state.\n        const output: ByteString = this.buildStateOutput(amount)\n        // Verify unlocking tx has this single output.\n        assert(this.ctx.hashOutputs == hash256(output), 'hashOutputs mismatch')\n    }\n\n    @method(SigHash.ANYONECANPAY_SINGLE)\n    public pay() {\n        // Check if all signed.\n        let nValid = 0n\n        for (let i = 0; i < 3; i++) {\n            if (this.owners[i].validated) {\n                nValid += 1n\n            }\n        }\n        assert(\n            nValid == 3,\n            'Not enough valid signatures.'\n        )\n\n        // Make sure balance in the contract does not change.\n        const amount: bigint = this.ctx.utxo.value\n        // Pay destination address\n        const output: ByteString = Utils.buildPublicKeyHashOutput(\n            this.dest,\n            amount\n        )\n        // Verify unlocking tx has this output.\n        assert(this.ctx.hashOutputs == hash256(output), 'hashOutputs mismatch')\n    }\n\n}\n")),(0,s.kt)("p",null,"We can observe, that the contract has two public methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"add")," \u2014 this method takes as an input a valid signature and the index of the public key it belongs to. It first checks the validity of this signature and sets a flag if valid."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"pay")," \u2014 this method checks if every signer provided his signature. If so, it ensures the next output will pay the locked funds to the address stored in the ",(0,s.kt)("inlineCode",{parentName:"li"},"dest")," variable.")),(0,s.kt)("p",null,"While being more complex when compared to the stateless example, it offers the critical advantage that no coordination is needed between the signers. Both the collection of signatures and the payout are managed by the smart contract code itself."))}p.isMDXComponent=!0},4700:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/state-840abd7f63813067e9985495a8b59f65.jpg"}}]);