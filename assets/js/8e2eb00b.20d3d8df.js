"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[6297],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>d});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var c=a.createContext({}),l=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},u=function(t){var e=l(t.components);return a.createElement(c.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},h=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,c=t.parentName,u=i(t,["components","mdxType","originalType","parentName"]),h=l(n),d=r,m=h["".concat(c,".").concat(d)]||h[d]||p[d]||o;return n?a.createElement(m,s(s({ref:e},u),{},{components:n})):a.createElement(m,s({ref:e},u))}));function d(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i.mdxType="string"==typeof t?t:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4343:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3},s="Stateful Contracts",i={unversionedId:"how-to-write-a-contract/stateful-contract",id:"how-to-write-a-contract/stateful-contract",title:"Stateful Contracts",description:"Overview",source:"@site/docs/how-to-write-a-contract/stateful-contract.md",sourceDirName:"how-to-write-a-contract",slug:"/how-to-write-a-contract/stateful-contract",permalink:"/docs/how-to-write-a-contract/stateful-contract",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"ScriptContext",permalink:"/docs/how-to-write-a-contract/scriptcontext"},next:{title:"Built-ins",permalink:"/docs/how-to-write-a-contract/built-ins"}},c={},l=[{value:"Overview",id:"overview",level:2},{value:"Create a Stateful Contract",id:"create-a-stateful-contract",level:2},{value:"Stateful properties",id:"stateful-properties",level:3},{value:"Update states",id:"update-states",level:3}],u={toc:l};function p(t){let{components:e,...o}=t;return(0,r.kt)("wrapper",(0,a.Z)({},u,o,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stateful-contracts"},"Stateful Contracts"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"In Bitcoin's UTXO model, a smart contract is one-off and stateless by default, since the UTXO containing it is destroyed after being spent. Being stateless allows it to scale easily, the same as in ",(0,r.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/5836881/stateless-protocol-and-stateful-protocol"},"HTTP")," and ",(0,r.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/restful-statelessness/"},"REST APIs"),".\nA smart contract can simulate state by requiring\nthe output of the spending transaction containing the same contract but with the updated state, enabled by ",(0,r.kt)("a",{parentName:"p",href:"/docs/how-to-write-a-contract/scriptcontext"},"ScriptContext"),".\nThis is similar to making HTTP seem stateful by using cookies."),(0,r.kt)("p",null,"We divide a smart contract in the locking script of an output into two parts: code and state as shown below. The code part contains the business logic of a contract that encodes rules for state transition and must ",(0,r.kt)("strong",{parentName:"p"},"NOT")," change. State transition occurs when a transaction spends the output containing the old state and creates a new output containing the new state, while keeping the contract code intact.\nSince the new output contains the same contract code, its spending transaction must also retain the same code, otherwise it will fail. This chain of transactions can go on and on and thus a state is maintained along the chain, recursively.\n",(0,r.kt)("img",{src:n(9915).Z,width:"2704",height:"774"})),(0,r.kt)("h2",{id:"create-a-stateful-contract"},"Create a Stateful Contract"),(0,r.kt)("p",null,"We can create a stateful contract using the following command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"scrypt project --state my-project\n")),(0,r.kt)("p",null,"Note the ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," option is turned on."),(0,r.kt)("p",null,"This will create a project containing a sample stateful contract named ",(0,r.kt)("inlineCode",{parentName:"p"},"Counter"),". This contract maintains a single state: how many times it has been called since deployment."),(0,r.kt)("p",null,"Let's take a look at the contract source file ",(0,r.kt)("inlineCode",{parentName:"p"},"src/contracts/counter.ts"),"."),(0,r.kt)("h3",{id:"stateful-properties"},"Stateful properties"),(0,r.kt)("p",null,"As shown ",(0,r.kt)("a",{parentName:"p",href:"/docs/how-to-write-a-contract/#properties"},"before"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"@prop(true)")," decorator is used to make a property part of the contract state, meaning it can be mutated when the contract gets called."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@prop(true)\ncount: bigint\n")),(0,r.kt)("h3",{id:"update-states"},"Update states"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"incrementOnChain()")," method does two things:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Call ",(0,r.kt)("inlineCode",{parentName:"li"},"increment")," to update the state:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@method()\nincrement(): void {\n    this.count++\n}\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Validate the new state goes into the next UTXO containing the same contract, i.e., the state is maintained.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// make sure balance in the contract does not change\nconst amount: bigint = this.ctx.utxo.value\n// output containing the latest state\nconst output: ByteString = this.buildStateOutput(amount)\n// verify current tx has this single output\nassert(this.ctx.hashOutputs == hash256(output), 'hashOutputs mismatch')\n")),(0,r.kt)("p",null,"The built-in function ",(0,r.kt)("inlineCode",{parentName:"p"},"this.buildStateOutput()")," creates an output containing the latest state. It takes an input: the number of satoshis in the output. We keep the satoshis unchanged in the example. If all outputs (only a single output here) we create in the contract hashes to ",(0,r.kt)("inlineCode",{parentName:"p"},"hashOutputs")," in ",(0,r.kt)("a",{parentName:"p",href:"/docs/how-to-write-a-contract/scriptcontext"},"ScriptContext"),", we can be sure they are the outputs of the current transaction. Therefore, the updated state is propagated."),(0,r.kt)("p",null,"The complete stateful contract is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export class Counter extends SmartContract {\n  // stateful\n  @prop(true)\n  count: bigint\n\n  constructor(count: bigint) {\n    super(...arguments)\n    this.count = count\n  }\n\n  @method(SigHash.ANYONECANPAY_SINGLE)\n  public incrementOnChain() {\n    this.increment()\n\n    // make sure balance in the contract does not change\n    const amount: bigint = this.ctx.utxo.value\n    // output containing the latest state\n    const output: ByteString = this.buildStateOutput(amount)\n    // verify current tx has this single output\n    assert(this.ctx.hashOutputs == hash256(output), 'hashOutputs mismatch')\n  }\n\n  @method()\n  increment(): void {\n      this.count++\n  }\n}\n")))}p.isMDXComponent=!0},9915:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/state-840abd7f63813067e9985495a8b59f65.jpg"}}]);