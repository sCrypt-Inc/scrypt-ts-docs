"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[1448],{3905:(t,e,n)=>{n.d(e,{Zo:()=>l,kt:()=>m});var r=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?a(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,r,o=function(t,e){if(null==t)return{};var n,r,o={},a=Object.keys(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var u=r.createContext({}),c=function(t){var e=r.useContext(u),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},l=function(t){var e=c(t.components);return r.createElement(u.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(t,e){var n=t.components,o=t.mdxType,a=t.originalType,u=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),d=c(n),m=o,h=d["".concat(u,".").concat(m)]||d[m]||p[m]||a;return n?r.createElement(h,i(i({ref:e},l),{},{components:n})):r.createElement(h,i({ref:e},l))}));function m(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var u in e)hasOwnProperty.call(e,u)&&(s[u]=e[u]);s.originalType=t,s.mdxType="string"==typeof t?t:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},721:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const a={title:"buildStateOutputNFT",sidebar_position:2},i=void 0,s={unversionedId:"tokens/nft/buildstateoutputnft",id:"tokens/nft/buildstateoutputnft",title:"buildStateOutputNFT",description:"Any instance of an OrdinalNFT contains the buildStateOutputNFT method. In contrast to the regular buildStateOutput method, this method also removes any inscription data that might be included in the smart contract's locking script. This is necessary because, within a stateful smart contract, we don't want the next iteration to re-inscribe the ordinal. Additionally, the buildStateOutputNFT method doesn't require a satoshi amount argument, as the amount is always 1 satoshi.",source:"@site/docs/tokens/nft/buildstateoutputnft.md",sourceDirName:"tokens/nft",slug:"/tokens/nft/buildstateoutputnft",permalink:"/tokens/nft/buildstateoutputnft",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"buildStateOutputNFT",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Transfer Existing NFT to a Smart Contract",permalink:"/tokens/nft/existing"},next:{title:"Funglible Tokens - FTs",permalink:"/tokens/ft/"}},u={},c=[],l={toc:c};function p(t){let{components:e,...n}=t;return(0,o.kt)("wrapper",(0,r.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Any instance of an ",(0,o.kt)("inlineCode",{parentName:"p"},"OrdinalNFT")," contains the ",(0,o.kt)("inlineCode",{parentName:"p"},"buildStateOutputNFT")," method. In contrast to the regular ",(0,o.kt)("inlineCode",{parentName:"p"},"buildStateOutput")," method, this method also removes any inscription data that might be included in the smart contract's locking script. This is necessary because, within a stateful smart contract, we don't want the next iteration to re-inscribe the ordinal. Additionally, the ",(0,o.kt)("inlineCode",{parentName:"p"},"buildStateOutputNFT")," method doesn't require a satoshi amount argument, as the amount is always 1 satoshi."),(0,o.kt)("p",null,"Below is an example of an ordinal counter contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class CounterNFT extends OrdinalNFT {\n\n    @prop(true)\n    counter: bigint\n\n    constructor(counter: bigint) {\n        super()\n        this.init(counter)\n        this.counter = counter\n    }\n\n    @method()\n    public incOnchain() {\n        this.counter++\n        \n        ...\n\n        let outputs = this.buildStateOutputNFT()  // Does not include inscription in the next iteration.\n        outputs += this.buildChangeOutput()\n        assert(\n            this.ctx.hashOutputs == hash256(outputs),\n            'hashOutputs check failed'\n        )\n    }\n\n}\n")),(0,o.kt)("p",null,"See the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/scrypt-ord/blob/master/tests/contracts/counterNFT.ts"},"complete code on GitHub"),"."))}p.isMDXComponent=!0}}]);