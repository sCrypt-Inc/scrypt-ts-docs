"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[7139],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>p});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),h=c(r),p=i,b=h["".concat(l,".").concat(p)]||h[p]||d[p]||a;return r?n.createElement(b,s(s({ref:t},u),{},{components:r})):n.createElement(b,s({ref:t},u))}));function p(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,s=new Array(a);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<a;c++)s[c]=r[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},2165:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var n=r(7462),i=(r(7294),r(3905));const a={sidebar_position:7},s="Tutorial 7: Escrow",o={unversionedId:"tutorials/escrow",id:"tutorials/escrow",title:"Tutorial 7: Escrow",description:"Overview",source:"@site/docs/tutorials/escrow.md",sourceDirName:"tutorials",slug:"/tutorials/escrow",permalink:"/tutorials/escrow",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Tutorial 6: Voting",permalink:"/tutorials/voting"},next:{title:"FAQ",permalink:"/faq"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"What is an escrow smart contract?",id:"what-is-an-escrow-smart-contract",level:3},{value:"Our implementation",id:"our-implementation",level:3},{value:"Contract properties",id:"contract-properties",level:2},{value:"Public method - <code>confirmPayment</code>",id:"public-method---confirmpayment",level:2},{value:"Public method - <code>refund</code>",id:"public-method---refund",level:2},{value:"Public method - <code>refundDeadline</code>",id:"public-method---refunddeadline",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:c};function d(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tutorial-7-escrow"},"Tutorial 7: Escrow"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"In this tutorial, we will go over how to create and escrow smart contract with some advanced features, such as a requirement for multiple arbiters and a deadline, after which the buyer can get a refund."),(0,i.kt)("h3",{id:"what-is-an-escrow-smart-contract"},"What is an escrow smart contract?"),(0,i.kt)("p",null,"An escrow smart contract is a type of digital agreement that Bitcoin to facilitate transactions between parties in a secure, trustless manner. "),(0,i.kt)("p",null,"In traditional escrow services, a trusted third party holds assets\u2014like money, property, or goods\u2014on behalf of the transacting parties. The assets are released only when specific conditions are met."),(0,i.kt)("p",null,'In the case of an escrow smart contract, the "third party" is the smart contract itself, programmed on the blockchain. The contract is written with the conditions of the transaction, and if they are met, the contract can be unlocked and the recipient(s) get payed.'),(0,i.kt)("h3",{id:"our-implementation"},"Our implementation"),(0,i.kt)("p",null,"We will implement a specific type of escrow, called a multi-sig escrow. The participants of this contract are a buyer (Alice), a seller (Bob) and one or more arbiters."),(0,i.kt)("p",null,"Suppose Alice want's to buy a specific item from Bob. They don't trust each other, so they decide to use an escrow smart contract. They pick one or more arbiters, which they both trust. The job of the chosen arbiters is to verify, that the item really gets delivered in the right condition. If the conditions are met, the contract will pay the seller, Bob. In the opposite case, Alice gets a refund. Additionally, Alice is also eligible for a refund after a set period of time in the case the arbiters are not responsive."),(0,i.kt)("h2",{id:"contract-properties"},"Contract properties"),(0,i.kt)("p",null,"Let's declare the properties of our smart contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Number of arbiters chosen.\nstatic readonly N_ARBITERS = 3\n\n// Buyer (Alice) address.\n@prop()\nreadonly buyerAddr: Addr\n\n// Seller (Bob) address.\n@prop()\nreadonly sellerAddr: Addr\n\n// Arbiter public keys.\n@prop()\nreadonly arbiters: FixedArray<PubKey, typeof MultiSigEscrow.N_ARBITERS>\n\n// Contract deadline nLocktime value.\n// Either timestamp or block height.\n@prop()\nreadonly deadline: bigint\n")),(0,i.kt)("h2",{id:"public-method---confirmpayment"},"Public method - ",(0,i.kt)("inlineCode",{parentName:"h2"},"confirmPayment")),(0,i.kt)("p",null,"The first method of our contract will be ",(0,i.kt)("inlineCode",{parentName:"p"},"confirmPayment"),". This public method will be called if the item was successfully delivered in the right condition."),(0,i.kt)("p",null,"The method takes as inputs the buyers signature, along with her public key and the signatures of the arbiters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Buyer and arbiters confirm, that the item was delivered.\n// Seller gets paid.\n@method(SigHash.ANYONECANPAY_SINGLE)\npublic confirmPayment(\n    buyerSig: Sig,\n    buyerPubKey: PubKey,\n    arbiterSigs: FixedArray<Sig, typeof MultiSigEscrow.N_ARBITERS>\n) {\n    // Validate buyer sig.\n    assert(\n        pubKey2Addr(buyerPubKey) == this.buyerAddr,\n        'invalid public key for buyer'\n    )\n    assert(\n        this.checkSig(buyerSig, buyerPubKey),\n        'buyer signature check failed'\n    )\n\n    // Validate arbiter sigs.\n    assert(\n        this.checkMultiSig(arbiterSigs, this.arbiters),\n        'arbiters checkMultiSig failed'\n    )\n\n    // Ensure seller gets payed.\n    const amount = this.ctx.utxo.value\n    const out = Utils.buildPublicKeyHashOutput(this.sellerAddr, amount)\n    assert(hash256(out) == this.ctx.hashOutputs, 'hashOutputs mismatch')\n}\n")),(0,i.kt)("p",null,"The method validates all signatures are correct and ensures the ",(0,i.kt)("strong",{parentName:"p"},"seller")," receives the funds."),(0,i.kt)("h2",{id:"public-method---refund"},"Public method - ",(0,i.kt)("inlineCode",{parentName:"h2"},"refund")),(0,i.kt)("p",null,"Next, we implement the public method ",(0,i.kt)("inlineCode",{parentName:"p"},"refund"),". If the delivery wasn't successful or there is something wrong with the item and needs to be sent back, the buyer is eligible for a refund."),(0,i.kt)("p",null,"The method again takes as inputs the buyers signature, along with her public key and the signatures of the arbiters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Regular refund. Needs arbiters agreement.\n@method()\npublic refund(\n    buyerSig: Sig,\n    buyerPubKey: PubKey,\n    arbiterSigs: FixedArray<Sig, typeof MultiSigEscrow.N_ARBITERS>\n) {\n    // Validate buyer sig.\n    assert(\n        pubKey2Addr(buyerPubKey) == this.buyerAddr,\n        'invalid public key for buyer'\n    )\n    assert(\n        this.checkSig(buyerSig, buyerPubKey),\n        'buyer signature check failed'\n    )\n\n    // Validate arbiter sigs.\n    assert(\n        this.checkMultiSig(arbiterSigs, this.arbiters),\n        'arbiters checkMultiSig failed'\n    )\n\n    // Ensure buyer gets refund.\n    const amount = this.ctx.utxo.value\n    const out = Utils.buildPublicKeyHashOutput(this.buyerAddr, amount)\n    assert(hash256(out) == this.ctx.hashOutputs, 'hashOutputs mismatch')\n}\n")),(0,i.kt)("p",null,"The method validates all signatures are correct and ensures the ",(0,i.kt)("strong",{parentName:"p"},"buyer")," receives the refund."),(0,i.kt)("h2",{id:"public-method---refunddeadline"},"Public method - ",(0,i.kt)("inlineCode",{parentName:"h2"},"refundDeadline")),(0,i.kt)("p",null,"Lastly, we implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"refundDeadline")," method. This method can be called, after the specified contract deadline has been reached. After the deadline, the buyer can receive the refund, even without the arbiters agreement."),(0,i.kt)("p",null,"The method takes as inputs in the buyers signature, along with her public key."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Deadline for delivery. If reached, the  buyer gets refunded.\n@method()\npublic refundDeadline(buyerSig: Sig, buyerPubKey: PubKey) {\n    assert(\n        pubKey2Addr(buyerPubKey) == this.buyerAddr,\n        'invalid public key for buyer'\n    )\n    assert(\n        this.checkSig(buyerSig, buyerPubKey),\n        'buyer signature check failed'\n    )\n\n    // Require nLocktime enabled https://wiki.bitcoinsv.io/index.php/NLocktime_and_nSequence\n    assert(\n        this.ctx.sequence < UINT_MAX,\n        'require nLocktime enabled'\n    )\n\n    // Check if using block height.\n    if (this.deadline < LOCKTIME_BLOCK_HEIGHT_MARKER) {\n        // Enforce nLocktime field to also use block height.\n        assert(\n            this.ctx.locktime < LOCKTIME_BLOCK_HEIGHT_MARKER\n        )\n    }\n    assert(this.ctx.locktime >= this.deadline, 'deadline not yet reached')\n\n    // Ensure buyer gets refund.\n    const amount = this.ctx.utxo.value\n    const out = Utils.buildPublicKeyHashOutput(this.buyerAddr, amount)\n    assert(hash256(out) == this.ctx.hashOutputs, 'hashOutputs mismatch')\n}\n")),(0,i.kt)("p",null,"The method checks the buyers signature validity. It also checks the transaction nLocktime value, to ensure it can be accepted by miners only after the deadline."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Congratulations! You have completed the escrow tutorial!"),(0,i.kt)("p",null,"The full code can be found in our ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/multisigEscrow.ts"},"boilerplate repository"),"."))}d.isMDXComponent=!0}}]);