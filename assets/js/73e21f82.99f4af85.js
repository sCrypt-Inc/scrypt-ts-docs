"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[275],{3905:(n,t,e)=>{e.d(t,{Zo:()=>p,kt:()=>m});var a=e(7294);function r(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function o(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,a)}return e}function l(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?o(Object(e),!0).forEach((function(t){r(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function c(n,t){if(null==n)return{};var e,a,r=function(n,t){if(null==n)return{};var e,a,r={},o=Object.keys(n);for(a=0;a<o.length;a++)e=o[a],t.indexOf(e)>=0||(r[e]=n[e]);return r}(n,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(a=0;a<o.length;a++)e=o[a],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(r[e]=n[e])}return r}var i=a.createContext({}),s=function(n){var t=a.useContext(i),e=t;return n&&(e="function"==typeof n?n(t):l(l({},t),n)),e},p=function(n){var t=s(n.components);return a.createElement(i.Provider,{value:t},n.children)},u={inlineCode:"code",wrapper:function(n){var t=n.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(n,t){var e=n.components,r=n.mdxType,o=n.originalType,i=n.parentName,p=c(n,["components","mdxType","originalType","parentName"]),d=s(e),m=r,h=d["".concat(i,".").concat(m)]||d[m]||u[m]||o;return e?a.createElement(h,l(l({ref:t},p),{},{components:e})):a.createElement(h,l({ref:t},p))}));function m(n,t){var e=arguments,r=t&&t.mdxType;if("string"==typeof n||r){var o=e.length,l=new Array(o);l[0]=d;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=n,c.mdxType="string"==typeof n?n:r,l[1]=c;for(var s=2;s<o;s++)l[s]=e[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,e)}d.displayName="MDXCreateElement"},1277:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>s});var a=e(7462),r=(e(7294),e(3905));const o={sidebar_position:8},l="Call Multiple Contracts in a Single Tx",c={unversionedId:"advanced/how-to-call-multiple-contracts",id:"advanced/how-to-call-multiple-contracts",title:"Call Multiple Contracts in a Single Tx",description:"Up to now, we have only shown how to call one smart contract in a transaction. That is, only one input of the tx spends a smart contract UTXO, and the other inputs, if any, spend Pay-to-Public-Key-Hash (P2PKH) UTXOs, which are generally NOT regarded as smart contracts.",source:"@site/docs/advanced/how-to-call-multiple-contracts.md",sourceDirName:"advanced",slug:"/advanced/how-to-call-multiple-contracts",permalink:"/advanced/how-to-call-multiple-contracts",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"How to Add a Signer",permalink:"/advanced/how-to-add-a-signer"},next:{title:"Time Lock",permalink:"/advanced/timeLock"}},i={},s=[],p={toc:s};function u(n){let{components:t,...e}=n;return(0,r.kt)("wrapper",(0,a.Z)({},p,e,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"call-multiple-contracts-in-a-single-tx"},"Call Multiple Contracts in a Single Tx"),(0,r.kt)("p",null,"Up to now, we have only shown how to call one smart contract in a transaction. That is, only one input of the tx spends a smart contract UTXO, and the other inputs, if any, spend Pay-to-Public-Key-Hash (",(0,r.kt)("a",{parentName:"p",href:"https://learnmeabitcoin.com/guide/p2pkh"},"P2PKH"),") UTXOs, which are generally NOT regarded as smart contracts."),(0,r.kt)("p",null,"There are cases where it is desirable to spend multiple smart contract UTXOs in different inputs of a tx."),(0,r.kt)("p",null,"The main differences from ",(0,r.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/#contract-call"},"calling a single contract")," are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"multiContractCall = true")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"MethodCallOptions")),(0,r.kt)("li",{parentName:"ol"},"Each call may only return a partial/incomplete transaction, instead of a complete transaction"),(0,r.kt)("li",{parentName:"ol"},"A partial tx has to be passed as ",(0,r.kt)("inlineCode",{parentName:"li"},"ContractTransaction")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"MethodCallOptions")," in subsequent calls"),(0,r.kt)("li",{parentName:"ol"},"Finally invoke ",(0,r.kt)("inlineCode",{parentName:"li"},"SmartContract.multiContractCall(partialContractTx: ContractTransaction, signer: Signer)")," to sign and broadcast the complete transaction")),(0,r.kt)("p",null,"The following is an ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/tests/multi_contracts_call.test.ts"},"example code")," of calling two contracts at the same time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Counter } from '../../src/contracts/counter'\nimport { getDefaultSigner } from '../utils/helper'\nimport { HashPuzzle } from '../../src/contracts/hashPuzzle'\n\nasync function main() {\n    await Counter.loadArtifact()\n    await HashPuzzle.loadArtifact()\n\n    const signer = getDefaultSigner()\n    let counter = new Counter(1n)\n\n    // connect to a signer\n    await counter.connect(signer)\n\n    // contract deployment\n    const deployTx = await counter.deploy(1)\n    console.log('Counter contract deployed: ', deployTx.id)\n\n    counter.bindTxBuilder(\n        'incrementOnChain',\n        (\n            current: Counter,\n            options: MethodCallOptions<Counter>,\n            ...args: any\n        ): Promise<ContractTransaction> => {\n            // create the next instance from the current\n            const nextInstance = current.next()\n            // apply updates on the next instance locally\n            nextInstance.count++\n\n            const tx = new bsv.Transaction()\n            tx.addInput(current.buildContractInput()).addOutput(\n                new bsv.Transaction.Output({\n                    script: nextInstance.lockingScript,\n                    satoshis: current.balance,\n                })\n            )\n\n            return Promise.resolve({\n                tx: tx,\n                atInputIndex: 0,\n                nexts: [\n                    {\n                        instance: nextInstance,\n                        balance: current.balance,\n                        atOutputIndex: 0,\n                    },\n                ],\n            })\n        }\n    )\n\n    const plainText = 'abc'\n    const byteString = toByteString(plainText, true)\n    const sha256Data = sha256(byteString)\n\n    const hashPuzzle = new HashPuzzle(sha256Data)\n\n    // connect to a signer\n    await hashPuzzle.connect(signer)\n\n    const deployTx1 = await hashPuzzle.deploy(1)\n    console.log('HashPuzzle contract deployed: ', deployTx1.id)\n\n    hashPuzzle.bindTxBuilder(\n        'unlock',\n        (\n            current: HashPuzzle,\n            options: MethodCallOptions<HashPuzzle>,\n            ...args: any\n        ): Promise<ContractTransaction> => {\n            if (options.partialContractTx) {\n                const unSignedTx = options.partialContractTx.tx\n                unSignedTx.addInput(\n                    current.buildContractInput()\n                )\n                \n                if (options.changeAddress) {\n                    unSignedTx.change(options.changeAddress)\n                }\n\n                return Promise.resolve({\n                    tx: unSignedTx,\n                    atInputIndex: 1,\n                    nexts: [],\n                })\n            }\n\n            throw new Error('no partialContractTx found')\n        }\n    )\n\n    const partialTx = await counter.methods.incrementOnChain({\n        multiContractCall: true,\n    } as MethodCallOptions<Counter>)\n\n    const finalTx = await hashPuzzle.methods.unlock(\n        byteString,\n        {\n            multiContractCall: true,\n            partialContractTx: partialTx,\n            changeAddress: await signer.getDefaultAddress()\n        } as MethodCallOptions<HashPuzzle>\n    )\n\n    const { tx: callTx, nexts } = await SmartContract.multiContractCall(\n        finalTx,\n        signer\n    )\n\n    console.log('Counter, HashPuzzle contract `unlock` called: ', callTx.id)\n\n    // hashPuzzle has terminated, but counter can still be called\n    counter = nexts[0].instance\n}\n\nawait main()\n\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"You must bind a ",(0,r.kt)("a",{parentName:"li",href:"/how-to-deploy-and-call-a-contract/#tx-builders"},"transaction builder")," to each contract instance, since ",(0,r.kt)("a",{parentName:"li",href:"/how-to-deploy-and-call-a-contract/how-to-customize-a-contract-tx#customize-1"},"the default")," only spends a single contract UTXO."),(0,r.kt)("li",{parentName:"ul"},"If the called contracts need signatures from different private keys to be called, the signer passed to ",(0,r.kt)("inlineCode",{parentName:"li"},"multiContractCall")," must have all private keys."))))}u.isMDXComponent=!0}}]);