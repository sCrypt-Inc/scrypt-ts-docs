"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[4617],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=i,m=c["".concat(o,".").concat(h)]||c[h]||u[h]||l;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<l;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},639:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const l={sidebar_position:4},r="Built-ins",s={unversionedId:"how-to-write-a-contract/built-ins",id:"how-to-write-a-contract/built-ins",title:"Built-ins",description:"Global Functions",source:"@site/docs/how-to-write-a-contract/built-ins.md",sourceDirName:"how-to-write-a-contract",slug:"/how-to-write-a-contract/built-ins",permalink:"/how-to-write-a-contract/built-ins",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Stateful Contracts",permalink:"/how-to-write-a-contract/stateful-contract"},next:{title:"How to Deploy & Call a Contract",permalink:"/how-to-deploy-and-call-a-contract/"}},o={},p=[{value:"Global Functions",id:"global-functions",level:2},{value:"Assert",id:"assert",level:3},{value:"Fill",id:"fill",level:3},{value:"Math",id:"math",level:3},{value:"Hashing",id:"hashing",level:3},{value:"ByteString Operations",id:"bytestring-operations",level:3},{value:"Bitwise Operator",id:"bitwise-operator",level:3},{value:"Exit",id:"exit",level:3},{value:"<code>SmartContract</code> Methods",id:"smartcontract-methods",level:2},{value:"<code>compile</code>",id:"compile",level:3},{value:"<code>scriptSize</code>",id:"scriptsize",level:3},{value:"<code>loadArtifact</code>",id:"loadartifact",level:3},{value:"<code>checkSig</code>",id:"checksig",level:3},{value:"<code>checkMultiSig</code>",id:"checkmultisig",level:3},{value:"<code>buildStateOutput</code>",id:"buildstateoutput",level:3},{value:"<code>buildChangeOutput</code>",id:"buildchangeoutput",level:3},{value:"<code>insertCodeSeparator</code>",id:"insertcodeseparator",level:3},{value:"<code>fromTx</code>",id:"fromtx",level:3},{value:"<code>buildDeployTransaction</code>",id:"builddeploytransaction",level:3},{value:"<code>bindTxBuilder</code>",id:"bindtxbuilder",level:3},{value:"<code>multiContractCall</code>",id:"multicontractcall",level:3},{value:"Standard Libraries",id:"standard-libraries",level:2},{value:"<code>Utils</code>",id:"utils",level:3},{value:"<code>HashedMap</code>",id:"hashedmap",level:3},{value:"On-chain",id:"on-chain",level:4},{value:"Off-chain",id:"off-chain",level:4},{value:"<code>HashedSet</code>",id:"hashedset",level:3},{value:"On-chain",id:"on-chain-1",level:4},{value:"Off-chain",id:"off-chain-1",level:4},{value:"<code>Constants</code>",id:"constants",level:3}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"built-ins"},"Built-ins"),(0,i.kt)("h2",{id:"global-functions"},"Global Functions"),(0,i.kt)("p",null,"The following functions come with ",(0,i.kt)("inlineCode",{parentName:"p"},"sCrypt"),"."),(0,i.kt)("h3",{id:"assert"},"Assert"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"assert(condition: boolean, errorMsg?: string)")," Throw an ",(0,i.kt)("inlineCode",{parentName:"li"},"Error")," with the optional error message if ",(0,i.kt)("inlineCode",{parentName:"li"},"condition")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),". Otherwise, nothing happens.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"assert(1n === 1n)        // nothing happens\nassert(1n === 2n)        // throws Error('Execution failed')\nassert(false, 'hello')   // throws Error('Execution failed, hello')\n")),(0,i.kt)("h3",{id:"fill"},"Fill"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fill(value: T, length: number): T[length] ")," Returns an ",(0,i.kt)("inlineCode",{parentName:"li"},"FixedArray")," with all ",(0,i.kt)("inlineCode",{parentName:"li"},"size")," elements set to ",(0,i.kt)("inlineCode",{parentName:"li"},"value"),", where ",(0,i.kt)("inlineCode",{parentName:"li"},"value")," can be any type. ")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"length")," must be a ",(0,i.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/#compile-time-constant"},"compiled-time constant"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// good\nfill(1n, 3) // numeric literal 3\nfill(1n, M) // const M = 3\nfill(1n, Demo.N) // `N` is a static readonly property of class `Demo`\n")),(0,i.kt)("h3",{id:"math"},"Math"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"abs(a: bigint): bigint")," Returns the absolute value of ",(0,i.kt)("inlineCode",{parentName:"li"},"a"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"abs(1n)  // 1n\nabs(0n)  // 0n\nabs(-1n) // 1n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"min(a: bigint, b: bigint): bigint")," Returns the smallest of ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"b"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"min(1n, 2n) // 1n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max(a: bigint, b: bigint): bigint")," Returns the lagest of ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"b"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"max(1n, 2n) // 2n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"within(x: bigint, min: bigint, max: bigint): boolean")," Returns ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," is within the specified range (left-inclusive and right-exclusive), ",(0,i.kt)("inlineCode",{parentName:"li"},"false")," otherwise.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"within(0n, 0n, 2n) // true\nwithin(1n, 0n, 2n) // true\nwithin(2n, 0n, 2n) // false\n")),(0,i.kt)("h3",{id:"hashing"},"Hashing"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ripemd160(a: ByteString): Ripemd160")," Returns the ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/RIPEMD"},"RIPEMD160")," hash result of ",(0,i.kt)("inlineCode",{parentName:"li"},"a"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sha1(a: ByteString): Sha1")," Returns the ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/SHA-1"},"SHA1")," hash result of ",(0,i.kt)("inlineCode",{parentName:"li"},"a"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sha256(a: ByteString): Sha256")," Returns the ",(0,i.kt)("a",{parentName:"li",href:"https://www.movable-type.co.uk/scripts/sha256.html"},"SHA256")," hash result of ",(0,i.kt)("inlineCode",{parentName:"li"},"a"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hash160(a: ByteString): Ripemd160")," Actually returns ",(0,i.kt)("inlineCode",{parentName:"li"},"ripemd160(sha256(a))")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hash256(a: ByteString): Sha256")," Actually returns ",(0,i.kt)("inlineCode",{parentName:"li"},"sha256(sha256(a))"))),(0,i.kt)("h3",{id:"bytestring-operations"},"ByteString Operations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"int2ByteString(n: bigint, size?: bigint): ByteString")," If ",(0,i.kt)("inlineCode",{parentName:"li"},"size")," is omitted, convert ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," is converted to a ",(0,i.kt)("inlineCode",{parentName:"li"},"ByteString")," in ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Signed_number_representations#Sign%E2%80%93magnitude"},"sign-magnitude")," little endian format, with as few bytes as possible (a.k.a., minimally encoded). Otherwise, converts the number ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," to a ",(0,i.kt)("inlineCode",{parentName:"li"},"ByteString")," of the specified size, including the sign bit; fails if the number cannot be accommodated.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// as few bytes as possible\nint2ByteString(128n)   // '8000', little endian\nint2ByteString(127n)   // '7f'\nint2ByteString(0n)     // ''\nint2ByteString(-1n)    // '81'\nint2ByteString(-129n)  // '8180', little endian\n\n// specified size\nint2ByteString(1n, 3n)        // '010000', 3 bytes\nint2ByteString(-129n, 3n)     // '810080', 3 bytes\n\n// Error: -129 cannot fit in 1 byte\nint2ByteString(-129n, 1n)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"byteString2Int(a: ByteString): bigint")," Convert ByteString in sign-magnitude little endian format to bigint.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"byteString2Int(toByteString('8000'))    // 128n\nbyteString2Int(toByteString(''))        // 0n\nbyteString2Int(toByteString('00'))      // 0n\nbyteString2Int(toByteString('81'))      // -1n\n\nbyteString2Int(toByteString('010000'))  // 1n\nbyteString2Int(toByteString('810080'))  // -129n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"len(a: ByteString): number")," Returns the byte length of ",(0,i.kt)("inlineCode",{parentName:"li"},"a"),". ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const s1 = toByteString('0011', false) // '0011', 2 bytes\nlen(s1) // 2\n\nconst s2 = toByteString('hello', true) // '68656c6c6f', 5 bytes\nlen(s2) // 5\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reverseByteString(b: ByteString, size: number): ByteString")," Returns reversed bytes of ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," which is of ",(0,i.kt)("inlineCode",{parentName:"li"},"size")," bytes. It is often useful when converting a number between little-endian and big-endian.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"size")," must be a ",(0,i.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/#compile-time-constant"},"compiled-time constant"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const s1 = toByteString('793ff39de7e1dce2d853e24256099d25fa1b1598ee24069f24511d7a2deafe6c') \nreverseByteString(s1, 32) // 6cfeea2d7a1d51249f0624ee98151bfa259d095642e253d8e2dce1e79df33f79\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"slice(byteString: ByteString, start: BigInt, end?: BigInt): ByteString")," return a sub-byte string from ",(0,i.kt)("inlineCode",{parentName:"li"},"start")," to, but not including, ",(0,i.kt)("inlineCode",{parentName:"li"},"end"),". If ",(0,i.kt)("inlineCode",{parentName:"li"},"end")," is not specified, the sub-byte string continues to the last byte.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const message = toByteString('001122')\nslice(message, 1n) // '1122'\nslice(message, 1n, 2n) // '11'\n")),(0,i.kt)("h3",{id:"bitwise-operator"},"Bitwise Operator"),(0,i.kt)("p",null,"Bigint in the Bitcoin is stored in ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Signed_number_representations#Sign%E2%80%93magnitude"},"sign\u2013magnitude format"),", not ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Signed_number_representations#Two's_complement"},"two's complement format")," commonly used. If the operands are all nonnegative, the result of the operation is consistent with TypeScript's bitwise operator, except ",(0,i.kt)("inlineCode",{parentName:"p"},"~"),". Otherwise, the operation results may be inconsistent and thus undefined. It is strongly recommended to ",(0,i.kt)("strong",{parentName:"p"},"NEVER")," apply bitwise operations on negative numbers."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"and(x: bigint, y: bigint): bigint")," Bitwise AND")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"and(13n, 5n) // 5n\nand(0x0a32c845n, 0x149f72n) // 0x00108840n, 1083456n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"or(x: bigint, y: bigint): bigint")," Bitwise OR")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"or(13n, 5n) // 13n\nor(0x0a32c845n, 0x149f72n) // 0xa36df77n, 171368311n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"xor(x: bigint, y: bigint): bigint")," Bitwise XOR")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"xor(13n, 5n) // 8n\nxor(0x0a32c845n, 0x149f72n) // 0x0a265737n, 170284855n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"invert(x: bigint): bigint")," Bitwise NOT")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"invert(13n)  // -114n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lshift(x: bigint, n: bigint): bigint")," Arithmetic left shift, returns ",(0,i.kt)("inlineCode",{parentName:"li"},"x * 2^n"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"lshift(2n, 3n)   // 16n\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rshift(x: bigint, n: bigint): bigint")," Arithmetic right shift, returns ",(0,i.kt)("inlineCode",{parentName:"li"},"x / 2^n"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"rshift(21n, 3n)    // 2n\nrshift(1024n, 11n) // 0n\n")),(0,i.kt)("h3",{id:"exit"},"Exit"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"exit(status: boolean): void")," Calling this function will terminate contract execution. If ",(0,i.kt)("inlineCode",{parentName:"li"},"status")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," then the contract succeeds; otherwise, it fails.")),(0,i.kt)("h2",{id:"smartcontract-methods"},(0,i.kt)("inlineCode",{parentName:"h2"},"SmartContract")," Methods"),(0,i.kt)("p",null,"The following ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s come with the ",(0,i.kt)("inlineCode",{parentName:"p"},"SmartContract")," base class."),(0,i.kt)("h3",{id:"compile"},(0,i.kt)("inlineCode",{parentName:"h3"},"compile")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"static async compile(): Promise<TranspileError[]>")," compiles the contract and returns transpile errors if compiling fails."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// returns transpile errors if compiling fails\nconst transpileErrors = await Demo.compile()\n")),(0,i.kt)("h3",{id:"scriptsize"},(0,i.kt)("inlineCode",{parentName:"h3"},"scriptSize")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"get scriptSize(): number")," returns the byte length of the contract locking script."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const demo = new Demo()\nconst size = demo.scriptSize\n")),(0,i.kt)("h3",{id:"loadartifact"},(0,i.kt)("inlineCode",{parentName:"h3"},"loadArtifact")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"static loadArtifact(artifactFile: Artifact | string | undefined = undefined)")," loads the contract artifact file from the path you passed in order to initialize the contract class."),(0,i.kt)("p",null,"If no parameters are passed when calling, the function will load the artifact file from the default directory. This form is generally used when ",(0,i.kt)("a",{parentName:"p",href:"/how-to-test-a-contract#load-artifact"},"testing")," the contract."),(0,i.kt)("p",null,"You can also pass the artifact itself directly. This form will be used when the method is called at the front end."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { TicTacToe } from './contracts/tictactoe';\nimport artifact from '../artifacts/tictactoe.json';\nTicTacToe.loadArtifact(artifact);\n")),(0,i.kt)("p",null,"You may visit ",(0,i.kt)("a",{parentName:"p",href:"https://academy.scrypt.io/en/courses/Build-a-Tic-tac-toe-Game-with-sCrypt-614c387bc0974f55df5af1e5/lessons/2/chapters/1"},"here")," for more details about how to add a front end to a contract."),(0,i.kt)("h3",{id:"checksig"},(0,i.kt)("inlineCode",{parentName:"h3"},"checkSig")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"checkSig(signature: Sig, publicKey: PubKey): boolean")," verifies an ECDSA signature. It takes two inputs: an ECDSA signature and a public key. "),(0,i.kt)("p",null,"It returns if the signature matches the public key."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"All signature checking functions (",(0,i.kt)("inlineCode",{parentName:"p"},"checkSig")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"checkMultiSig"),") follow the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki#NULLFAIL"},(0,i.kt)("strong",{parentName:"a"},"NULLFAIL")," rule"),": if the signature is invalid, the entire contract aborts and fails immediately, unless the signature is an empty ByteString, in which case these functions return ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),".")),(0,i.kt)("p",null,"For example, Pay-to-Public-Key-Hash (",(0,i.kt)("a",{parentName:"p",href:"https://learnmeabitcoin.com/guide/p2pkh"},"P2PKH"),") can be implemented as below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class P2PKH extends SmartContract {\n  // public key hash of the recipient.\n  @prop()\n  readonly pubKeyHash: PubKeyHash\n\n  constructor(pubKeyHash: PubKeyHash) {\n    super(...arguments)\n    this.pubKeyHash = pubKeyHash\n  }\n\n  @method()\n  public unlock(sig: Sig, pubkey: PubKey) {\n    // check if the passed public key belongs to the specified public key hash\n    assert(hash160(pubkey) == this.pubKeyHash, 'public key hashes are not equal')\n    // check signature validity\n    assert(this.checkSig(sig, pubkey), 'signature check failed')\n  }\n}\n")),(0,i.kt)("h3",{id:"checkmultisig"},(0,i.kt)("inlineCode",{parentName:"h3"},"checkMultiSig")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"checkMultiSig(signatures: Sig[], publickeys: PubKey[]): boolean")," verifies an array of ECDSA signatures. It takes two inputs: an array of ECDSA signatures and an array of public keys."),(0,i.kt)("p",null,"The function compares the first signature against each public key until it finds an ECDSA match. Starting with the subsequent public key, it compares the second signature against each remaining public key until it finds an ECDSA match. The process is repeated until all signatures have been checked or not enough public keys remain to produce a successful result. All signatures need to match a public key. Because public keys are not checked again if they fail any signature comparison, signatures must be placed in the ",(0,i.kt)("inlineCode",{parentName:"p"},"signatures")," array using the same order as their corresponding public keys were placed in the ",(0,i.kt)("inlineCode",{parentName:"p"},"publickeys")," array. If all signatures are valid, ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," is returned, ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class MultiSigPayment extends SmartContract {\n  // public key hashes of the 3 recipients\n  @prop()\n  readonly pubKeyHashes: FixedArray<PubKeyHash, 3>\n\n  constructor(pubKeyHashes: FixedArray<PubKeyHash, 3>) {\n    super(...arguments)\n    this.pubKeyHashes = pubKeyHashes\n  }\n\n  @method()\n  public unlock(\n      signatures: FixedArray<Sig, 3>, \n      publicKeys: FixedArray<PubKey, 3>\n    ) {\n    // check if the passed public keys belong to the specified public key hashes\n    for (let i = 0; i < 3; i++) {\n      assert(hash160(publicKeys[i]) == this.pubKeyHashes[i], 'public key hash mismatch\xb8')\n    }\n    // validate signatures\n    assert(this.checkMultiSig(signatures, publicKeys), 'checkMultiSig failed')\n  }\n}\n")),(0,i.kt)("h3",{id:"buildstateoutput"},(0,i.kt)("inlineCode",{parentName:"h3"},"buildStateOutput")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"buildStateOutput(amount: bigint): ByteString")," creates an output containing the latest state. It takes an input: the number of satoshis in the output."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Counter extends SmartContract {\n  // ...\n\n  @method(SigHash.ANYONECANPAY_SINGLE)\n  public incOnChain() {\n    // ... update state\n      \n    // construct the new state output \n    const output: ByteString = this.buildStateOutput(this.ctx.utxo.value)\n\n    // ... verify outputs of current tx\n  }\n}\n")),(0,i.kt)("h3",{id:"buildchangeoutput"},(0,i.kt)("inlineCode",{parentName:"h3"},"buildChangeOutput")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"buildChangeOutput(): ByteString")," creates a P2PKH change output. It will calculate the change amount (",(0,i.kt)("inlineCode",{parentName:"p"},"this.changeAmount"),") automatically, and use the signer's address by default, unless ",(0,i.kt)("inlineCode",{parentName:"p"},"changeAddress")," field is explicitly set in ",(0,i.kt)("inlineCode",{parentName:"p"},"MethodCallOptions"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Auction extends SmartContract {\n\n  // ...\n\n  @method()\n  public bid(bidder: PubKeyHash, bid: bigint) {\n    \n    // ...\n\n    // Auction continues with a higher bidder.\n    const auctionOutput: ByteString = this.buildStateOutput(bid)\n\n    // Refund previous highest bidder.\n    const refundOutput: ByteString = Utils.buildPublicKeyHashOutput(\n        highestBidder,\n        highestBid\n    )\n    let outputs: ByteString = auctionOutput + refundOutput\n\n    // Add change output.\n    outputs += this.buildChangeOutput()\n\n    assert(hash256(outputs) == this.ctx.hashOutputs, 'hashOutputs check failed')\n  }\n}\n")),(0,i.kt)("p",null,"Call ",(0,i.kt)("inlineCode",{parentName:"p"},"Auction")," contract with a custom change address."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst { tx: callTx, atInputIndex } = await auction.methods.bid(\n  PubKeyHash(toHex(publicKeyHashNewBidder)),\n  BigInt(balance + 1),\n  {\n    changeAddress: addressNewBidder, // specify the change address of method calling tx explicitly\n  } as MethodCallOptions<Auction>\n)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"this.changeAmount")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"this.buildChangeOutput")," can be accessed directly when using the ",(0,i.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/how-to-customize-a-contract-tx#default-1"},"default call tx builder"),", but if you use use a ",(0,i.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/how-to-customize-a-contract-tx#customize-1"},"customized call tx builder"),", you need to explicitly ",(0,i.kt)("a",{parentName:"p",href:"/bitcoin-basics/bsv#constructing-transactions"},"set the transaction change output")," in the builder beforehand.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const unsignedTx: bsv.Transaction = new bsv.Transaction()\n  // add inputs and outputs\n  // ...\n  // add change output explicitly\n  // otherwise you cannot call `this.changeAmount` and `this.buildChangeOutput` in the contract\n  .change(options.changeAddress);\n")),(0,i.kt)("h3",{id:"insertcodeseparator"},(0,i.kt)("inlineCode",{parentName:"h3"},"insertCodeSeparator")),(0,i.kt)("p",null,"Method ",(0,i.kt)("inlineCode",{parentName:"p"},"insertCodeSeparator(): void")," inserts an ",(0,i.kt)("a",{parentName:"p",href:"/advanced/codeseparator"},(0,i.kt)("inlineCode",{parentName:"a"},"OP_CODESEPARATOR")),", where it is invoked."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export class CodeSeparator extends SmartContract {\n\n    @prop()\n    readonly addresses: FixedArray<PubKeyHash, 3>;\n\n    constructor(addresses: FixedArray<PubKeyHash, 3>) {\n        super(...arguments);\n        this.addresses = addresses;\n    }\n\n    @method()\n    public unlock(sigs: FixedArray<Sig, 3>, pubKeys: FixedArray<PubKey, 3>) {\n        assert(hash160(pubKeys[0]) == this.addresses[0]);\n        this.insertCodeSeparator()\n        assert(this.checkSig(sigs[0], pubKeys[0]));\n\n        this.insertCodeSeparator()\n        assert(hash160(pubKeys[1]) == this.addresses[1]);\n        assert(this.checkSig(sigs[1], pubKeys[1]));\n\n        this.insertCodeSeparator()\n        assert(hash160(pubKeys[2]) == this.addresses[2]);\n        assert(this.checkSig(sigs[2], pubKeys[2]));\n    }\n\n}\n")),(0,i.kt)("h3",{id:"fromtx"},(0,i.kt)("inlineCode",{parentName:"h3"},"fromTx")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"static fromTx(tx: bsv.Transaction, atOutputIndex: number, offchainValues?: Record<string, any>)")," creates an instance with its state synchronized to a given transaction output, identified by ",(0,i.kt)("inlineCode",{parentName:"p"},"tx")," the transaction and ",(0,i.kt)("inlineCode",{parentName:"p"},"atOutputIndex")," the output index. It is needed to ",(0,i.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/#create-a-smart-contract-instance-from-a-transaction"},"create an up-to-date instance of a contract"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// create an instance from a transaction output\nconst instance = ContractName.fromTx(tx, atOutputIndex)\n\n// we're good here, the `instance` is state synchronized with the on-chain transaction\n")),(0,i.kt)("p",null,"If the contract contains @prop's of type ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedSet"),", the values of all these properties at this transaction must be passed in the third argument."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// e.g. the contract has two stateful properties of type `HashedMap` or `HashedSet`\n// @prop(true) mySet: HashedSet<bigint>\n// @prop() myMap: HashedMap<bigint, bigint>\nconst instance = ContractName.fromTx(tx, atOutputIndex, {\n    // pass the values of all these properties at the transaction moment\n    'mySet': currentSet,\n    'myMap': currentMap,\n})\n")),(0,i.kt)("h3",{id:"builddeploytransaction"},(0,i.kt)("inlineCode",{parentName:"h3"},"buildDeployTransaction")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"async buildDeployTransaction(utxos: UTXO[], amount: number, changeAddress?: bsv.Address | string): Promise<bsv.Transaction>")," creates a tx to deploy the contract. The first parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"utxos")," represents one or more ",(0,i.kt)("a",{parentName:"p",href:"https://learnmeabitcoin.com/technical/p2pkh"},"P2PKH")," inputs for paying transaction fees. The second parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," is the balance of contract output. The last parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"changeAddress")," is optional and represents a change address. Users override it to ",(0,i.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/how-to-customize-a-contract-tx#customize"},"cutomize a deployment tx")," as below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"override async buildDeployTransaction(utxos: UTXO[], amount: number, changeAddress?: bsv.Address | string): Promise<bsv.Transaction> {\n    const deployTx = new bsv.Transaction()\n      // add p2pkh inputs for paying tx fees\n      .from(utxos) \n      // add contract output\n      .addOutput(new bsv.Transaction.Output({\n        script: this.lockingScript,\n        satoshis: amount,\n      }))\n    // add the change output if passing `changeAddress`\n    if (changeAddress) {\n      deployTx.change(changeAddress);\n      if (this._provider) {\n        deployTx.feePerKb(await this.provider.getFeePerKb());\n      }\n    }\n\n    return deployTx;\n  }\n")),(0,i.kt)("h3",{id:"bindtxbuilder"},(0,i.kt)("inlineCode",{parentName:"h3"},"bindTxBuilder")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"bindTxBuilder(methodName: string, txBuilder: MethodCallTxBuilder<SmartContract>):void")," binds the customized transaction builder ",(0,i.kt)("inlineCode",{parentName:"p"},"MethodCallTxBuilder"),", which returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractTransation"),", to a contract public ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," identified by ",(0,i.kt)("inlineCode",{parentName:"p"},"methodName"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'\n/**\n * A transaction builder.\n * The default transaction builder only supports fixed-format call transactions. \n * Some complex contracts require a custom transaction builder to successfully call the contract.\n */\nexport interface MethodCallTxBuilder<T extends SmartContract> {\n  (current: T, options: MethodCallOptions<T>, ...args: any): Promise<ContractTransaction>\n}\n\n\n// bind a customized tx builder for the public method `instance.unlock()`\ninstance.bindTxBuilder("unlock", (options: MethodCallOptions<T>, ...args: any) => {\n  // ...\n})\n')),(0,i.kt)("p",null,"You may visit ",(0,i.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/how-to-customize-a-contract-tx#customize-1"},"here")," to see more details on how to customize tx builder."),(0,i.kt)("h3",{id:"multicontractcall"},(0,i.kt)("inlineCode",{parentName:"h3"},"multiContractCall")),(0,i.kt)("p",null,"When the ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s of multiple contracts is called in a transaction, the transaction builders for each contract collectively construct the ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractTransation"),". Function ",(0,i.kt)("inlineCode",{parentName:"p"},"static async multiContractCall(partialContractTx: ContractTransaction, signer: Signer): Promise<MultiContractTransaction>")," signs and broadcasts the final transaction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const partialContractTx1 = await counter1.methods.incrementOnChain(\n    {\n        multiContractCall: true,\n    } as MethodCallOptions<Counter>\n)\n\nconst partialContractTx2 = await counter2.methods.incrementOnChain(\n    {\n        multiContractCall: true,\n        partialContractTx: partialContractTx1\n    } as MethodCallOptions<Counter>\n);\n\nconst {tx: callTx, nexts} = await SmartContract.multiContractCall(partialContractTx2, signer)\n\n\nconsole.log('Counter contract counter1, counter2 called: ', callTx.id)\n")),(0,i.kt)("h2",{id:"standard-libraries"},"Standard Libraries"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sCrypt")," comes with standard libraries that define many commonly used functions."),(0,i.kt)("h3",{id:"utils"},(0,i.kt)("inlineCode",{parentName:"h3"},"Utils")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Utils")," library provides a set of commonly used utility functions."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static toLEUnsigned(n: bigint, l: bigint): ByteString")," Convert the signed integer ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," to an unsigned integer of ",(0,i.kt)("inlineCode",{parentName:"li"},"l")," bytes, in sign-magnitude little endian format.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"Utils.toLEUnsigned(10n, 3n)   // '0a0000'\nUtils.toLEUnsigned(-10n, 2n)  // '0a00'\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static fromLEUnsigned(bytes: ByteString): bigint")," Convert ByteString to unsigned integer.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"Utils.fromLEUnsigned(toByteString('0a00'))  // 10n\nUtils.fromLEUnsigned(toByteString('8a'))    // 138n, actually converts 8a00 to unsigned integer\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static readVarint(buf: ByteString): ByteString")," Read a ",(0,i.kt)("a",{parentName:"li",href:"https://learnmeabitcoin.com/technical/varint"},"VarInt")," field from ",(0,i.kt)("inlineCode",{parentName:"li"},"buf"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"Utils.readVarint(toByteString('0401020304')) // '01020304'\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static writeVarint(buf: ByteString): ByteString")," Convert ",(0,i.kt)("inlineCode",{parentName:"li"},"buf")," to a ",(0,i.kt)("a",{parentName:"li",href:"https://learnmeabitcoin.com/technical/varint"},"VarInt")," field, including the preceding length.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"Utils.writeVarint(toByteString('010203')) // '03010203'\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static buildOutput(outputScript: ByteString, outputSatoshis: bigint): ByteString")," Build a transaction output with the specified script and satoshi amount.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const lockingScript = toByteString('01020304')\nUtils.buildOutput(lockingScript, 1n) // '01000000000000000401020304'\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static buildPublicKeyHashScript(pubKeyHash: PubKeyHash ): ByteString")," Build a ",(0,i.kt)("a",{parentName:"li",href:"https://wiki.bitcoinsv.io/index.php/Bitcoin_Transactions#Pay_to_Public_Key_Hash_.28P2PKH.29"},"Pay to Public Key Hash (P2PKH)")," script from a public key hash.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const pubKeyHash = PubKeyHash(toByteString('0011223344556677889900112233445566778899'))\nUtils.buildPublicKeyHashScript(pubKeyHash) // '76a914001122334455667788990011223344556677889988ac'\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static buildPublicKeyHashOutput(pubKeyHash: PubKeyHash, amount: bigint): ByteString")," Build a P2PKH output from the public key hash.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const pubKeyHash = PubKeyHash(toByteString('0011223344556677889900112233445566778899'))\nUtils.buildPublicKeyHashOutput(pubKeyHash, 1n) // '01000000000000001976a914001122334455667788990011223344556677889988ac'\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static buildOpreturnScript(data: ByteString): ByteString")," Build a data-carrying ",(0,i.kt)("a",{parentName:"li",href:"https://wiki.bitcoinsv.io/index.php/OP_RETURN"},"FALSE OP_RETURN")," script from ",(0,i.kt)("inlineCode",{parentName:"li"},"data")," payload.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const data = toByteString('hello world', true)\nUtils.buildOpreturnScript(data) // '006a0b68656c6c6f20776f726c64'\n")),(0,i.kt)("h3",{id:"hashedmap"},(0,i.kt)("inlineCode",{parentName:"h3"},"HashedMap")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," provides a map/hashtable-like data structure. It is different to use ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," in on-chain and off-chain context."),(0,i.kt)("h4",{id:"on-chain"},"On-chain"),(0,i.kt)("p",null,"The main difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," and other data types we\u2019ve ",(0,i.kt)("a",{parentName:"p",href:"../how-to-write-a-contract/#data-types"},"previously introduced")," is that it does NOT store raw data (i.e., keys and values) in the contract on the blockchain. It stores their hashed values instead, to minimize on-chain storage, which is expensive."),(0,i.kt)("p",null,"These guidelines must be followed when using ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," in a contract ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),", i.e., on-chain context."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Only the following methods can be called."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"set(key: K, val: V): HashedMap"),": Adds a new element with a specified key and value. If an element with the same key already exists, the element will be updated."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"canGet(key: K, val: V): boolean"),": Returns ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," if the specified ",(0,i.kt)("strong",{parentName:"li"},"key and value pair")," exists, otherwise returns ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"has(key: K): boolean"),": Returns ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," if the specified key exists, otherwise returns ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"delete(key: K): boolean"),": Returns ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," if a key exists and has been removed, otherwise returns ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"clear(): void"),": Remove all key and value pairs."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"size: number"),": Returns the number of elements.")))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"get()")," is not listed, since the value itself is not stored and thus must be passed in and verified using ",(0,i.kt)("inlineCode",{parentName:"p"},"canGet()"),".")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The aforementioned methods can only be used in public ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s, NOT in non-public ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s, including constructors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," can be used as an ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop"),", either stateful or not:"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@prop() map: HashedMap<KeyType, ValueType>; // valid\n@prop(true) map: HashedMap<KeyType, ValueType> // also valid\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It CANNOT be used as a ",(0,i.kt)("inlineCode",{parentName:"li"},"@method")," parameter, regardless of public or not:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@method public unlock(map: HashedMap<KeyType, ValueType>) // invalid as a parameter type\n@method foo(map: HashedMap<KeyType, ValueType>) // invalid as a parameter type\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"No nesting is allowed currently. That is, key and value cannot contain a ",(0,i.kt)("inlineCode",{parentName:"li"},"HashedMap"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type Map1 = HashedMap<KeyType1, ValueType1>\nHashedMap<KeyType2, Map1> // invalid\nHashedMap<Map1, ValueType2> // invalid\n\ntype KeyType = {\n  key1: KeyType1\n  key2: KeyType2\n}\nHashedMap<KeyType, ValueType> // valid\n")),(0,i.kt)("p",null,"A full example may look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class MyContract extends SmartContract {\n  @prop(true)\n  myMap: HashedMap<bigint, bigint>;\n\n  // HashedMap can be a parameter in constructor\n  constructor(map: HashedMap<bigint, bigint>) {\n    // assignment is ok, but not calling method\n    this.myMap = map;\n  }\n\n  @method()\n  public unlock(key: bigint, val: bigint) {\n    this.myMap.set(key, val);\n    assert(this.myMap.has(key));\n    assert(this.myMap.canGet(key, val));\n    assert(this.myMap.delete(key));\n    assert(!this.myMap.has(key));\n  }\n}\n")),(0,i.kt)("h4",{id:"off-chain"},"Off-chain"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," acts just like the JavaScript/TypeScript ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"},"Map")," when used in off-chain code (that is, not in a contract's ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"). For example, you can create an instance like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// create an empty map\nlet hashedMap = new HashedMap<bigint, ByteString>();\n\n// create from (key,value) pairs\nlet hashedMap1 = new HashedMap([['key1', 'value1'], ['key2', 'value2']]);\n")),(0,i.kt)("p",null,"Also, you can call its functions like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"hashedMap.set(key, value);\nconst v = hashedMap.get(key);   // <----\nhashedMap.has(key);\nhashedMap.delete(key);\n...\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"get()")," can be called since the HashedMap stores the original key and value off chain.")),(0,i.kt)("p",null,"Only when the key is an object is ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," will treat two keys the same if they have the same values, while ",(0,i.kt)("inlineCode",{parentName:"p"},"Map")," will only if they reference the same object. For instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface ST {\n  a: bigint;\n}\n\nlet map = new Map<ST, bigint>();\nmap.set({a: 1n}, 1n);\nmap.set({a: 1n}, 2n);\nconsole.log(map.size); // output \u20182\u2019 cause two keys {a: 1n} reference differently\nconsole.log(map.get({a: 1n})); // output \u2018undefined\u2019\n\n\nlet hashedMap = new HashedMap<ST, bigint>();\nhashedMap.set({a: 1n}, 1n);\nhashedMap.set({a: 1n}, 2n);\nconsole.log(hashedMap.size); // output \u20181\u2019\nconsole.log(hashedMap.get({a: 1n})); // output \u20182n\u2019\n")),(0,i.kt)("h3",{id:"hashedset"},(0,i.kt)("inlineCode",{parentName:"h3"},"HashedSet")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"HashedSet")," library provides a set-like data structure. It can be regarded as a special ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap")," where a value is the same with its key and is thus omitted. Values are hashed before being stored in contracts on the blockchain, as in ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap"),"."),(0,i.kt)("h4",{id:"on-chain-1"},"On-chain"),(0,i.kt)("p",null,"When used in public ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s, ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedSet")," also has almost all of the same restrictions as ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap"),". Except for the methods on its own whitelist that can be called in ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s as following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"add(value: T): HashedSet"),": Inserts a new element with a specified value in to a set, if there isn't an element with the same value already in the set.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"has(value: T): boolean"),": Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if an element with the specified value exists in the set, otherwise returns ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"delete(value: T): boolean"),": Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if an element in the Set existed and has been removed, or false if the element does not exist.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"clear(): void"),": Delete all entries of the set.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"size: number"),": Returns the size of set, i.e. the number of the entries it contains."))),(0,i.kt)("h4",{id:"off-chain-1"},"Off-chain"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"HashedSet")," can be used the same as a JavaScript ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," in off-chain code ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let hashedSet = new HashedSet<bigint>()\nhashedSet.add(1n);\nhashedSet.has(1n);\nhashedSet.delete(1n);\n...\n")),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedMap"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"HashedSet")," will treat two objects as identical if their values equal, rather than requiring that they reference to the same object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface ST {\n  a: bigint;\n}\n\nlet set = new Set<ST>();\nset.add({a: 1n});\nset.add({a: 1n});\nconsole.log(set.size); // output \u20182\u2019\nconsole.log(set.has({a: 1n})); // output \u2018false\u2019\n\n\nlet hashedSet = new HashedSet<ST, bigint>();\nhashedSet.add({a: 1n});\nhashedSet.add({a: 1n});\nconsole.log(hashedSet.size); // output \u20181\u2019\nconsole.log(hashedSet.has({a: 1n})); // output \u2018true\u2019\n")),(0,i.kt)("h3",{id:"constants"},(0,i.kt)("inlineCode",{parentName:"h3"},"Constants")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Constants")," defines some commonly used constant values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class Constants {\n    // number of string to denote input sequence\n    static readonly InputSeqLen: bigint = BigInt(4);\n    // number of string to denote output value\n    static readonly OutputValueLen: bigint = BigInt(8);\n    // number of string to denote a public key (compressed)\n    static readonly PubKeyLen: bigint = BigInt(33);\n    // number of string to denote a public key hash\n    static readonly PubKeyHashLen: bigint = BigInt(20);\n    // number of string to denote a tx id\n    static readonly TxIdLen: bigint = BigInt(32);\n    // number of string to denote a outpoint\n    static readonly OutpointLen: bigint = BigInt(36);\n}\n")))}u.isMDXComponent=!0}}]);