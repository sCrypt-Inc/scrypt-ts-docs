"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[2441],{3905:(t,e,a)=>{a.d(e,{Zo:()=>h,kt:()=>d});var n=a(7294);function i(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function s(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function r(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?s(Object(a),!0).forEach((function(e){i(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,i=function(t,e){if(null==t)return{};var a,n,i={},s=Object.keys(t);for(n=0;n<s.length;n++)a=s[n],e.indexOf(a)>=0||(i[a]=t[a]);return i}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(n=0;n<s.length;n++)a=s[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(i[a]=t[a])}return i}var l=n.createContext({}),p=function(t){var e=n.useContext(l),a=e;return t&&(a="function"==typeof t?t(e):r(r({},e),t)),a},h=function(t){var e=p(t.components);return n.createElement(l.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},c=n.forwardRef((function(t,e){var a=t.components,i=t.mdxType,s=t.originalType,l=t.parentName,h=o(t,["components","mdxType","originalType","parentName"]),c=p(a),d=i,m=c["".concat(l,".").concat(d)]||c[d]||u[d]||s;return a?n.createElement(m,r(r({ref:e},h),{},{components:a})):n.createElement(m,r({ref:e},h))}));function d(t,e){var a=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var s=a.length,r=new Array(s);r[0]=c;var o={};for(var l in e)hasOwnProperty.call(e,l)&&(o[l]=e[l]);o.originalType=t,o.mdxType="string"==typeof t?t:i,r[1]=o;for(var p=2;p<s;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},4909:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const s={sidebar_position:7},r="Sighash Types",o={unversionedId:"advanced/sighash-type",id:"advanced/sighash-type",title:"Sighash Types",description:"A signature hash (sighash) flag is used to indicate which part of the transaction is signed by the ECDSA signature. There are mainly two ways to use it in the context of Bitcoin smart contracts.",source:"@site/docs/advanced/sighash-type.md",sourceDirName:"advanced",slug:"/advanced/sighash-type",permalink:"/advanced/sighash-type",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Use Script inside sCrypt",permalink:"/advanced/inline-asm"},next:{title:"Tutorials",permalink:"/category/tutorials"}},l={},p=[{value:"1. Sighash Types in Signatures",id:"1-sighash-types-in-signatures",level:2},{value:"Digital Signature",id:"digital-signature",level:3},{value:"Bitcoin Signature",id:"bitcoin-signature",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Crowdfunding",id:"crowdfunding",level:4},{value:"Blank Check",id:"blank-check",level:4},{value:"How to generate a signature with a specific sighash",id:"how-to-generate-a-signature-with-a-specific-sighash",level:3},{value:"2. Sighash Types in <code>@method()</code> Parameters",id:"2-sighash-types-in-method-parameters",level:2},{value:"Counter",id:"counter",level:3},{value:"Advanced Counter",id:"advanced-counter",level:3},{value:"More examples",id:"more-examples",level:3}],h={toc:p};function u(t){let{components:e,...s}=t;return(0,i.kt)("wrapper",(0,n.Z)({},h,s,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"sighash-types"},"Sighash Types"),(0,i.kt)("p",null,"A signature hash (sighash) flag is used to indicate which part of the transaction is signed by the ECDSA signature. There are mainly two ways to use it in the context of Bitcoin smart contracts."),(0,i.kt)("h2",{id:"1-sighash-types-in-signatures"},"1. Sighash Types in Signatures"),(0,i.kt)("p",null,"In this section, we will go deep into the sighash type and introduce how to use it in the bitcoin signatures."),(0,i.kt)("h3",{id:"digital-signature"},"Digital Signature"),(0,i.kt)("p",null,"A digital signature is a mathematical scheme that consists of two parts\uff1a"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"an algorithm for creating a signature, using a private key to sign a message.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"sign(privateKey, message) --\x3e signature\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"an algorithm that allows anyone to verify the signature, given also the message and a public key.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"verify(signature, publicKey, message) --\x3e true/false\n")),(0,i.kt)("p",null,"The private key and the public key always appear in pairs, and the public key can be calculated from the private key, but not vice versa. Thus, you will always publish the public key so anyone can verify your signature, and keep the private key safe so only you can provide the correct signature."),(0,i.kt)("p",null,"Digital signatures are used to represent the authenticity and integrity of a message, since any modification to the message invalidates the signature, causing signature verification to fail. It is also proof that someone owns the private key, since the signature cannot be forged and it can be successfully verified with the corresponding public key only if it is signed with the correct private key."),(0,i.kt)("h3",{id:"bitcoin-signature"},"Bitcoin Signature"),(0,i.kt)("p",null,"Digital signatures are applied to messages, which in the case of bitcoin, are the transactions themselves. The signature implies a commitment by the signer to specific transaction data. In the simplest form, the signature applies to the entire transaction, thereby committing all the inputs, outputs, and other transaction fields. The P2PKH transaction is a simple example of using signatures, which is widely used in bitcoin."),(0,i.kt)("p",null,"Bitcoin signatures have a way of indicating which part of a transaction\u2019s data is included signed by the private key using a sighash flag. The included transaction data, that's so call ",(0,i.kt)("inlineCode",{parentName:"p"},"ScriptContext"),". Every signature has a sighash flag and the flag can be different from signature to signature. "),(0,i.kt)("p",null,"There are three sighash flags: ",(0,i.kt)("inlineCode",{parentName:"p"},"ALL"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"NONE"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"SINGLE"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Sighash flag"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ALL"),(0,i.kt)("td",{parentName:"tr",align:null},"Signature applies to all inputs and outputs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"NONE"),(0,i.kt)("td",{parentName:"tr",align:null},"Signature applies to all inputs, none of the outputs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SINGLE"),(0,i.kt)("td",{parentName:"tr",align:null},"Signature applies to all inputs but only the one output with the same index number as the signed input")))),(0,i.kt)("p",null,"In addition, there is a modifier flag ",(0,i.kt)("inlineCode",{parentName:"p"},"ANYONECANPAY"),", which can be combined with each of the preceding flags. When ",(0,i.kt)("inlineCode",{parentName:"p"},"ANYONECANPAY")," is set, only one input is signed, leaving the rest inputs open for modification."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Sighash flag"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ALL","|","ANYONECANPAY"),(0,i.kt)("td",{parentName:"tr",align:null},"Signature applies to one input and all outputs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"NONE","|","ANYONECANPAY"),(0,i.kt)("td",{parentName:"tr",align:null},"Signature applies to one input, none of the outputs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SINGLE","|","ANYONECANPAY"),(0,i.kt)("td",{parentName:"tr",align:null},"Signature applies to one input and the output with the same index number")))),(0,i.kt)("p",null,"All the six flags can be summarized in the following diagram."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(4296).Z,width:"1053",height:"745"})),(0,i.kt)("p",null,"As described in the ",(0,i.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/scriptcontext#sighash-type"},"doc")," before, different sighash type decides which part of the spending transaction is included in ",(0,i.kt)("inlineCode",{parentName:"p"},"ScriptContext"),". More specifically, it will affect the value of four fields: ",(0,i.kt)("inlineCode",{parentName:"p"},"hashPrevouts"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"hashSequence"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"hashOutputs"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"sigHashType"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Field"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"hashPrevouts"),(0,i.kt)("td",{parentName:"tr",align:null},"If the ",(0,i.kt)("inlineCode",{parentName:"td"},"ANYONECANPAY")," modifier is not set, it's double SHA256 of the serialization of all input outpoints. Otherwise, it's a ",(0,i.kt)("inlineCode",{parentName:"td"},"unit256")," of ",(0,i.kt)("inlineCode",{parentName:"td"},"0x0000......0000"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"hashSequence"),(0,i.kt)("td",{parentName:"tr",align:null},"If none of the ",(0,i.kt)("inlineCode",{parentName:"td"},"ANYONECANPAY"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"SINGLE"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"NONE")," is set, it's double SHA256 of the serialization of sequence of all inputs. Otherwise, it's a ",(0,i.kt)("inlineCode",{parentName:"td"},"unit256")," of ",(0,i.kt)("inlineCode",{parentName:"td"},"0x0000......0000"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"hashOutputs"),(0,i.kt)("td",{parentName:"tr",align:null},"If the sighash type is neither ",(0,i.kt)("inlineCode",{parentName:"td"},"SINGLE")," nor ",(0,i.kt)("inlineCode",{parentName:"td"},"NONE"),", it's double SHA256 of the serialization of all outputs. If the sighash type is ",(0,i.kt)("inlineCode",{parentName:"td"},"SINGLE")," and the input index is smaller than the number of outputs, it's the double SHA256 of the output with the same index as the input. Otherwise, it's a ",(0,i.kt)("inlineCode",{parentName:"td"},"unit256")," of ",(0,i.kt)("inlineCode",{parentName:"td"},"0x0000......0000"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sigHashType"),(0,i.kt)("td",{parentName:"tr",align:null},"sighash type of the signature")))),(0,i.kt)("h3",{id:"use-cases"},"Use Cases"),(0,i.kt)("p",null,"For a transaction signed with the default sighash ",(0,i.kt)("inlineCode",{parentName:"p"},"ALL"),", it cannot be modified in any way. This is because the signature commits to all inputs and outputs of the transaction, if any part changes, the signature and thus the transactio becomes invalid. This is desirable in most cases, because the sender does not want others to temper with the signed transaction."),(0,i.kt)("p",null,"Let\u2019s look at some examples using non-default sighash types."),(0,i.kt)("h4",{id:"crowdfunding"},"Crowdfunding"),(0,i.kt)("p",null,"Someone attempting to raise funds can construct a transaction with a single output. The single output pays a target amount to a fundraiser. Such a transaction is obviously invalid, as it has no inputs. Others can amend it by adding an input of their own, as a donation. They sign their own input with ",(0,i.kt)("inlineCode",{parentName:"p"},"ALL|ANYONECANPAY")," and pass the partially signed transactions to the next donor. ",(0,i.kt)("inlineCode",{parentName:"p"},"ALL")," ensures the output and thus the target and fundraiser cannot be modified. ",(0,i.kt)("inlineCode",{parentName:"p"},"ANYONECANPAY"),' ensures anyone can pay by adding new inputs without invalidating existing donors\' signatures. Each donation is a "pledge" which cannot be collected by the fundraiser until the entire target amount is raised.'),(0,i.kt)("h4",{id:"blank-check"},"Blank Check"),(0,i.kt)("p",null,"Someone attempting to write a blank check can construct a transaction with several inputs and no output, and sign all the inputs with ",(0,i.kt)("inlineCode",{parentName:"p"},"NONE"),". The signatures only commit to inputs of the transaction. This allows anyone to add their desired outputs to the transaction to spend the funds in anyway she wants."),(0,i.kt)("h3",{id:"how-to-generate-a-signature-with-a-specific-sighash"},"How to generate a signature with a specific sighash"),(0,i.kt)("p",null,"For those contract public methods that require one or more signatures as input parameters, we can specify different sighash types for the signatures when calling it."),(0,i.kt)("p",null,"Take the ",(0,i.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/#method-with-signatures"},"P2PKH contract")," as an example, it requires a signature to ",(0,i.kt)("inlineCode",{parentName:"p"},"unlock"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@method()\npublic unlock(sig: Sig, pubkey: PubKey) {\n    // Check if the passed public key belongs to the specified address.\n    assert(hash160(pubkey) == this.pubKeyHash, 'public key hashes are not equal')\n    // Check signature validity.\n    assert(this.checkSig(sig, pubkey), 'signature check failed')\n}\n")),(0,i.kt)("p",null,"There are two changes to specify a sighash type, which defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"ALL")," if not specified explicitly."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Pass a ",(0,i.kt)("inlineCode",{parentName:"li"},"SignatureOption")," object to ",(0,i.kt)("inlineCode",{parentName:"li"},"pubKeyOrAddrToSign")," to specify the sighash type."),(0,i.kt)("li",{parentName:"ol"},"Pass the sighash as the third parameter of ",(0,i.kt)("inlineCode",{parentName:"li"},"findSig()"),".")),(0,i.kt)("p",null,"The following example uses ",(0,i.kt)("inlineCode",{parentName:"p"},"SINGLE"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const sighash = SignatureHashType.SINGLE\nconst { tx } = await p2pkh.methods.unlock(\n    (sigResps) => findSig(sigResps, publicKey, sighash), // 2) specify SINGLE as well when finding a signature\n    PubKey(toHex(publicKey)),\n    {\n        pubKeyOrAddrToSign: {\n            pubKeyOrAddr: publicKey,\n            sigHashType: sighash, // 1) sign with SINGLE\n        }\n    } as MethodCallOptions<P2PKH>\n)\n")),(0,i.kt)("h2",{id:"2-sighash-types-in-method-parameters"},"2. Sighash Types in ",(0,i.kt)("inlineCode",{parentName:"h2"},"@method()")," Parameters"),(0,i.kt)("p",null,"In this section, we will introduce how to specify different sighash types in the ",(0,i.kt)("inlineCode",{parentName:"p"},"@method()")," decorator."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Sighash here only affects contracts that access ",(0,i.kt)("inlineCode",{parentName:"p"},"ScriptContext")," in their public methods.")),(0,i.kt)("h3",{id:"counter"},"Counter"),(0,i.kt)("p",null,"Let us use the ",(0,i.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/stateful-contract"},"Counter")," contract as an example. It simply records how many times it has been called since deployment."),(0,i.kt)("p",null,"Noted that the ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," ",(0,i.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/#method-decorator"},"decorator")," takes a sighash type as a parameter, whose default is ",(0,i.kt)("inlineCode",{parentName:"p"},"ALL"),". According to the ",(0,i.kt)("a",{parentName:"p",href:"/how-to-write-a-contract/scriptcontext#sighash-type"},"doc"),",  ",(0,i.kt)("inlineCode",{parentName:"p"},"hashOutputs")," is the double SHA256 of the serialization of ",(0,i.kt)("strong",{parentName:"p"},"all outputs")," when the sighash type is ",(0,i.kt)("inlineCode",{parentName:"p"},"ALL"),". The ",(0,i.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/how-to-customize-a-contract-tx#default-1"},"default calling transaction builder")," adds a change output when necessary. That's why we need to add a change output when building outputs of the spending transaction in the public method: we need to build all the outputs that are included in ",(0,i.kt)("inlineCode",{parentName:"p"},"hashOutputs"),". Otherwise, contract call will fail."),(0,i.kt)("p",null,"The following ",(0,i.kt)("a",{parentName:"p",href:"https://test.whatsonchain.com/tx/845f22b728deb23acacbc6f58f23ffde9c3e2be976e08c57f2bdcb417e3eacc5"},"transaction")," is a contract calling transaction of ",(0,i.kt)("inlineCode",{parentName:"p"},"Counter"),". As you can see, it contains two outputs: one for the new state, the other for change."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(4877).Z,width:"2504",height:"1528"})),(0,i.kt)("h3",{id:"advanced-counter"},"Advanced Counter"),(0,i.kt)("p",null,"Noted that in the state transition of ",(0,i.kt)("inlineCode",{parentName:"p"},"Counter"),", there is always only one UTXO that contains the latest contract state. When the contract is called, it spends the UTXO of the current state and creates a UTXO of the new state. Moreover, the contract input index of the spending transaction and the contract output index are the same."),(0,i.kt)("p",null,"In fact, we only care about the contract-related UTXO in the transaction inputs and outputs when calling Counter, and do not care about other inputs and outputs. Thus, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"SINGLE | ANYONECANPAY")," to simplify the contract.\n",(0,i.kt)("inlineCode",{parentName:"p"},"SINGLE")," lets us focus on the contract output itself.\n",(0,i.kt)("inlineCode",{parentName:"p"},"ANYONECANPAY")," allows anyone to add inputs for this contract calling transaction to, e.g., pay fees."),(0,i.kt)("p",null,"We make two changes to the original Counter."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Using ",(0,i.kt)("inlineCode",{parentName:"li"},"@method(SigHash.ANYONECANPAY_SINGLE)")),(0,i.kt)("li",{parentName:"ol"},"Build an ",(0,i.kt)("inlineCode",{parentName:"li"},"output")," that only contains the contract's new state, without the change output.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export class AdvancedCounter extends SmartContract {\n    ...\n    \n    // 1) add ANYONECANPAY_SINGLE\n    @method(SigHash.ANYONECANPAY_SINGLE)\n    public incrementOnChain() {\n        ...\n        \n        const amount: bigint = this.ctx.utxo.value\n        // 2) remove change output\n        const output: ByteString = this.buildStateOutput(amount)\n        assert(this.ctx.hashOutputs == hash256(output), 'hashOutputs mismatch')\n    }\n    \n    ...\n}\n")),(0,i.kt)("p",null,"You can check the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/advancedCounter.ts"},"complete code here"),"."),(0,i.kt)("p",null,"The following ",(0,i.kt)("a",{parentName:"p",href:"https://test.whatsonchain.com/tx/e06d86f8d8b867c503eca799bb542b5f1d1f81aa75ad00ab4377d65764bef68c"},"transaction")," is a contract calling transaction of ",(0,i.kt)("inlineCode",{parentName:"p"},"AdvancedCounter"),". You can see it also contains two outputs, but we only use one output when checking if it hashes to ",(0,i.kt)("inlineCode",{parentName:"p"},"hashOutputs")," in the public method, since we use ",(0,i.kt)("inlineCode",{parentName:"p"},"SINGLE"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(9321).Z,width:"2492",height:"1526"})),(0,i.kt)("h3",{id:"more-examples"},"More examples"),(0,i.kt)("p",null,"Use different sighash types in ",(0,i.kt)("inlineCode",{parentName:"p"},"@method()")," decorator will change the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"ScriptContext"),". This is useful in many cases."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If your contract needs to restrict all inputs and outputs of the spending transaction, use ",(0,i.kt)("inlineCode",{parentName:"li"},"ALL"),"."),(0,i.kt)("li",{parentName:"ul"},"If your contract is stateful and the state is always in a single output, simplify it using ",(0,i.kt)("inlineCode",{parentName:"li"},"SINGLE"),"."),(0,i.kt)("li",{parentName:"ul"},"If you want to enable someone else could add inputs after the transaction is sealed, such as for paying transaction fees, apply the ",(0,i.kt)("inlineCode",{parentName:"li"},"ANYONECANPAY")," modifier.")),(0,i.kt)("p",null,"You can check find examples in our ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/boilerplate"},"boilerplate"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/acs.ts"},"AnyoneCanSpend")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/clone.ts"},"Clone")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/erc20.ts"},"ERC20")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/erc721.ts"},"ERC721")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/sCrypt-Inc/boilerplate/blob/master/src/contracts/ordinalLock.ts"},"OrdinalLock"))))}u.isMDXComponent=!0},9321:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/advanced-counter-call-10d4de2cce2d5636da9d8e4b59301c28.png"},4877:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/counter-call-d056c6e9d9055b27de5635b82f741918.png"},4296:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/sighashtypes-8b0d4314acae2a58b674bcdf32b2e17f.png"}}]);