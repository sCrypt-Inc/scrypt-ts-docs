"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[3444],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),f=p(n),h=a,d=f["".concat(s,".").concat(h)]||f[h]||u[h]||o;return n?r.createElement(d,i(i({ref:t},c),{},{components:n})):r.createElement(d,i({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},6396:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_position:6},i="Tutorial 6: zk-SNARKs",l={unversionedId:"tutorials/zk-snark",id:"tutorials/zk-snark",title:"Tutorial 6: zk-SNARKs",description:"Overview",source:"@site/docs/tutorials/zk-snark.md",sourceDirName:"tutorials",slug:"/tutorials/zk-snark",permalink:"/docs/tutorials/zk-snark",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Tutorial 5: Reconstructing Deployed Contract",permalink:"/docs/tutorials/fromTx"},next:{title:"README",permalink:"/docs/reference/"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"What are zk-SNARKS?",id:"what-are-zk-snarks",level:3},{value:"Installing ZoKrates",id:"installing-zokrates",level:2},{value:"ZoKrates Workflow",id:"zokrates-workflow",level:2},{value:"1. Design a circuit",id:"1-design-a-circuit",level:3},{value:"2. Compile the circuit",id:"2-compile-the-circuit",level:3},{value:"3. Setup",id:"3-setup",level:3},{value:"4. Calculating a witness",id:"4-calculating-a-witness",level:3},{value:"5. Creating a proof",id:"5-creating-a-proof",level:3},{value:"6. Export an sCrypt verifier",id:"6-export-an-scrypt-verifier",level:3},{value:"The sCrypt Verifier",id:"the-scrypt-verifier",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"tutorial-6-zk-snarks"},"Tutorial 6: zk-SNARKs"),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"In this tutorial we will go over how to create a zero-knowledge proof (ZKP) and verify it on-chain using sCrypt."),(0,a.kt)("p",null,"As a simple example, we will create a proof that we know the factors of a specific number. The important bit is, that none of the factors will ever be publicly revealed."),(0,a.kt)("h3",{id:"what-are-zk-snarks"},"What are zk-SNARKS?"),(0,a.kt)("p",null,"zk-SNARKs, or Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge, are cryptographic proofs that allow one party to prove possession of information without revealing the actual information, ensuring privacy on a public blockchain, such as Bitcoin, and other applications."),(0,a.kt)("p",null,'A proof is constructed off-chain by a prover who generates the proof using a secret input (often referred to as the "witness") and a public statement, based on a pre-defined arithmetic circuit that represents the problem being solved. The prover can then use this proof as an input for an sCrypt smart contract, which can verify the validity of the proof using a verification key and the public statement.'),(0,a.kt)("p",null,"In our concrete example the secret input are the factors of a specific number, which is considered the public statement."),(0,a.kt)("p",null,"There are many tools for creating such proofs, ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/zokrates"},"ZoKrates")," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/snarkjs"},"SnarkJS")," are among the most popular. "),(0,a.kt)("p",null,"In this example we will use ZoKrates. It provides a python-like higher-level language for developers to code the computational problem they want to prove."),(0,a.kt)("p",null,"For a more comprehensive explanation of zk-SNARKS and how they work, we recommend reading ",(0,a.kt)("a",{parentName:"p",href:"https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell"},"this blog post"),"."),(0,a.kt)("h2",{id:"installing-zokrates"},"Installing ZoKrates"),(0,a.kt)("p",null,"Run the following command to install ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/zokrates/releases"},"released binaries"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"curl -Ls https://scrypt.io/scripts/setup-zokrates.sh | sh -s -\n")),(0,a.kt)("p",null,"or build from source:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"git clone https://github.com/sCrypt-Inc/zokrates\ncd ZoKrates\ncargo +nightly build -p zokrates_cli --release\ncd target/release\n")),(0,a.kt)("h2",{id:"zokrates-workflow"},"ZoKrates Workflow"),(0,a.kt)("h3",{id:"1-design-a-circuit"},"1. Design a circuit"),(0,a.kt)("p",null,"Create a new ZoKrates file named ",(0,a.kt)("inlineCode",{parentName:"p"},"factor.zok")," with the following content:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"// p, q are the factors of n\ndef main(private field p, private field q, field n) {\n    assert(p * q == n);\n    assert(p > 1);\n    assert(q > 1);\n    return;\n}\n")),(0,a.kt)("p",null,"This simple circuit/program proves one knows a factorization of an integer ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," into two integers, without revealing the factors. The circuit has two private inputs named ",(0,a.kt)("inlineCode",{parentName:"p"},"p")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"q")," and one public input named ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,a.kt)("h3",{id:"2-compile-the-circuit"},"2. Compile the circuit"),(0,a.kt)("p",null,"Compile the circuit with the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"zokrates compile -i factor.zok\n")),(0,a.kt)("p",null,"This generates two files that encode the circuit in binary and human-readable format."),(0,a.kt)("h3",{id:"3-setup"},"3. Setup"),(0,a.kt)("p",null,"This generates a proving key and a verification key for this circuit."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"zokrates setup\n")),(0,a.kt)("h3",{id:"4-calculating-a-witness"},"4. Calculating a witness"),(0,a.kt)("p",null,"A proof attests that a prover knows some secret/private information that satisfies the original program. This secret information is called witness. In the following example, ",(0,a.kt)("inlineCode",{parentName:"p"},"7")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"13")," are the witnesses, as they are factors of ",(0,a.kt)("inlineCode",{parentName:"p"},"91"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"zokrates compute-witness -a 7 13 91\n")),(0,a.kt)("p",null,"A file named ",(0,a.kt)("inlineCode",{parentName:"p"},"witness")," is generated."),(0,a.kt)("h3",{id:"5-creating-a-proof"},"5. Creating a proof"),(0,a.kt)("p",null,"The following command produces a proof, using both the proving key and the witness:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"zokrates generate-proof\n")),(0,a.kt)("p",null,"The resulting file ",(0,a.kt)("inlineCode",{parentName:"p"},"proof.json")," looks like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "scheme": "g16",\n  "curve": "bn128",\n  "proof": {\n    "a": [\n      "0x0a7ea3ca37865347396645d017c7623431d13103e9107c937d722e5da15f352b",\n      "0x040c202ba8fa153f84af8dabc2ca40ff534f54efeb3271acc04a70c41afd079b"\n    ],\n    "b": [\n      [\n        "0x0ec1e4faea792762de35dcfd0da0e6859ce491cafad455c334d2c72cb8b24550",\n        "0x0985ef1d036b41d44376c1d42ff803b7cab9f9d4cf5bd75298e0fab2d109f096"\n      ],\n      [\n        "0x265151afd8626b4c72dfefb86bac2b63489423d6cf895ed9fa186548b0b9e3f3",\n        "0x301f2b356621408e037649d0f5b4ad5f4b2333f58453791cc24f07d5673349bf"\n      ]\n    ],\n    "c": [\n      "0x2b75a257d68763100ca11afb3beae511732c1cd1d3f1ce1804cbc0c26043cb6b",\n      "0x2f80c706b58482eec9e759fce805585595a76c27e37b67af3463414246fbabbd"\n    ]\n  },\n  "inputs": [\n    "0x000000000000000000000000000000000000000000000000000000000000005b"\n  ]\n}\n')),(0,a.kt)("h3",{id:"6-export-an-scrypt-verifier"},"6. Export an sCrypt verifier"),(0,a.kt)("p",null,"Using our version of ZoKrates, we can export a project template, which will contain a verifier for our circuit. Simply run the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"zokrates export-verifier-scrypt\n")),(0,a.kt)("p",null,"This will create a directory named ",(0,a.kt)("inlineCode",{parentName:"p"},"verifier"),", containing the project. Let's set it up. Run the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"cd verifier && git init && npm i\n")),(0,a.kt)("p",null,"Now the verifier is ready to be used. In the following section we will go over the code and show how to use it."),(0,a.kt)("h3",{id:"the-scrypt-verifier"},"The sCrypt Verifier"),(0,a.kt)("p",null,"In the generated project, let's open the file ",(0,a.kt)("inlineCode",{parentName:"p"},"src/contracts/verifier.ts"),". This file contains all the sCrypt code that is used to verify a proof on-chain. This includes an elliptic curve implementation along with a library that implements pairings over that elliptic curve and lastly the implementation of the proof verification algorithm. In our example the ",(0,a.kt)("a",{parentName:"p",href:"https://hackmd.io/@jpw/bn254"},(0,a.kt)("inlineCode",{parentName:"a"},"BN-256")," elliptic curve")," is being used along with the ",(0,a.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2016/260.pdf"},(0,a.kt)("inlineCode",{parentName:"a"},"Groth-16")," proof system"),"."),(0,a.kt)("p",null,"As a developer you only need to know about the main ",(0,a.kt)("inlineCode",{parentName:"p"},"Verifier")," contract. Let's take a look at its implementation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export class Verifier extends SmartContract {\n    \n    @prop()\n    vk: VerifyingKey\n\n    constructor(vk: VerifyingKey) {\n        super(...arguments)\n        this.vk = vk\n    }\n    \n    @method()\n    public verifyProof(\n        inputs: FixedArray<bigint, 1>,\n        proof: Proof,\n    ) {\n        assert(G16BN256.verify(this.vk, inputs, proof))\n    }\n\n}\n")),(0,a.kt)("p",null,"As we can see, the contract has a single property, namely the verification key. ZoKrates already created an object named ",(0,a.kt)("inlineCode",{parentName:"p"},"VERIFYING_KEY_DATA")," in the same source file, which contains the values of the VK. We will use them later. "),(0,a.kt)("p",null,"The contract also has a public method named ",(0,a.kt)("inlineCode",{parentName:"p"},"verifyProof"),". As the name implies it verifies a ZK proof and can be unlocked by a valid one. As inputs it takes the public values of our proof (in our case the product of the factors) and the proof itself. It calls a single function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"G16BN256.verify(this.vk, inputs, proof)\n")),(0,a.kt)("p",null,"We can observe, that the implementation of the verification algorithm takes in the verifying key, the public inputs and the proof. It's important to note that the proof is cryptographically tied to the verifying key and thus must be a proof about the correct ZoKrates program (",(0,a.kt)("inlineCode",{parentName:"p"},"factor.zok"),")."),(0,a.kt)("p",null,"The current method accepts a proof for any number, as it takes the public information as an input. Let's modify a bit and make the value fixed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@method()\npublic verifyProof(\n    proof: Proof\n) {\n    const inputs: FixedArray<bigint, 1> = [ 441668n ]\n    assert(G16BN256.verify(this.vk, inputs, proof))\n}\n")),(0,a.kt)("p",null,"Now our smart contract will only accept a proof of knowing the factors of the number ",(0,a.kt)("inlineCode",{parentName:"p"},"441668"),"."),(0,a.kt)("p",null,"The generated project will also contain tests that demonstrate the usage of our verifier. Let's take a look at the code in ",(0,a.kt)("inlineCode",{parentName:"p"},"tests/local/verifier.test.ts"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"...\n\nlet verifier: Verifier\n\nbefore(async () => {\n    await Verifier.compile()\n    // Construct VerifyingKey struct with pre-calculated miller(beta, alpha)\n    let alpha = BN256.createCurvePoint(VERIFYING_KEY_DATA.alpha)\n    let beta = BN256.createTwistPoint(VERIFYING_KEY_DATA.beta)\n    let millerb1a1 = BN256Pairing.miller(beta, alpha)\n    \n    let vk: VerifyingKey = {\n       millerb1a1: millerb1a1,\n       gamma: VERIFYING_KEY_DATA.gamma,\n       delta: VERIFYING_KEY_DATA.delta,\n       gammaAbc: VERIFYING_KEY_DATA.gammaAbc\n    }\n    \n    verifier = new Verifier(vk)\n})\n\nit('should pass verify proof', () => {\n    // TODO: Link proof.json (relative to project root dir)\n    const proofPath = '../proof.json'\n    const proof: Proof = parseProofFile(proofPath)\n\n    // TODO: Insert public param values here (don't forget to adjust arr size):\n    const inputs: FixedArray<bigint, 1> = [ 0n ]\n\n    const result = verifier.verify((self) => {\n        self.verifyProof(inputs, proof)\n    })\n    expect(result.success, result.error).to.be.true\n})\n")),(0,a.kt)("p",null,"We can observe that we need to adjust two things. The first one is the path to our ",(0,a.kt)("inlineCode",{parentName:"p"},"proof.json")," file, which contains the proof created by ZoKrates. The second one are the values of the public inputs to our ZoKrates program. Because we already hardcoded this value into our contract in a previous step, we can adjust the code to the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"it('should pass verify proof', () => {\n    const proofPath = '../proof.json'\n    const proof: Proof = parseProofFile(proofPath)\n\n    const result = verifier.verify((self) => {\n        self.verifyProof(proof)\n    })\n    expect(result.success, result.error).to.be.true\n})\n")),(0,a.kt)("p",null,"Now that everything is ready, let's run the verification. Run this in the projects root directory:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"npm t\n")),(0,a.kt)("p",null,"If everything is right, the command should pass and successfully verify our proof."),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"Congratulations! You have successfully created a zk-SNARK and verified it using sCrypt."),(0,a.kt)("p",null,"If you want to learn how you can integrate zk-SNARKS into a fully fledged Bitcoin web application, then take a look at our ",(0,a.kt)("a",{parentName:"p",href:"https://learn.scrypt.io/en/courses/Build-a-zkSNARK-based-Battleship-Game-on-Bitcoin-64187ae0d1a6cb859d18d72a"},"course"),", which will teach you how to create a ZK Battleship game.\nAdditionally, it also teaches you to use ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/snarkjs"},"snarkjs/circom"),"."))}u.isMDXComponent=!0}}]);