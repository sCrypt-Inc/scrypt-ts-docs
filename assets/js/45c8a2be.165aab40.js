"use strict";(self.webpackChunkscrypt_docs=self.webpackChunkscrypt_docs||[]).push([[4661],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),l=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return a.createElement(d.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=l(t),g=r,h=u["".concat(d,".").concat(g)]||u[g]||p[g]||s;return t?a.createElement(h,i(i({ref:n},c),{},{components:t})):a.createElement(h,i({ref:n},c))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,i=new Array(s);i[0]=u;var o={};for(var d in n)hasOwnProperty.call(n,d)&&(o[d]=n[d]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var l=2;l<s;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4619:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var a=t(7462),r=(t(7294),t(3905));const s={sidebar_position:7},i="How to Add a Signer",o={unversionedId:"advanced/how-to-add-a-signer",id:"advanced/how-to-add-a-signer",title:"How to Add a Signer",description:"As described in this section, a signer is an abstraction of private keys, which can be used to sign messages and transactions. A simple signer would be a single private key, while a complex signer is a wallet.",source:"@site/docs/advanced/how-to-add-a-signer.md",sourceDirName:"advanced",slug:"/advanced/how-to-add-a-signer",permalink:"/advanced/how-to-add-a-signer",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"How to Add a Provider",permalink:"/advanced/how-to-add-a-provider"},next:{title:"Call Multiple Contracts in a Single Tx",permalink:"/advanced/how-to-call-multiple-contracts"}},d={},l=[{value:"Implementation",id:"implementation",level:2},{value:"Base Class <code>Signer</code>",id:"base-class-signer",level:3},{value:"<code>Example: PandaSigner</code>",id:"example-pandasigner",level:3},{value:"Use your signer",id:"use-your-signer",level:2}],c={toc:l};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-to-add-a-signer"},"How to Add a Signer"),(0,r.kt)("p",null,"As described in ",(0,r.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/#provider"},"this section"),", a signer is an abstraction of private keys, which can be used to sign messages and transactions. A simple signer would be a single private key, while a complex signer is a wallet."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"sCrypt")," provides the following signers by default:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"TestWallet")," : a simple wallet that can hold multiple private keys, with in-memory utxo management. Should only be used for testing."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"PandaSigner"),": a signer powered by the popular smart contract wallet ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/yours-org/yours-wallet/"},"Yours Wallet"),". Can be used ",(0,r.kt)("a",{parentName:"li",href:"/tokens/tutorials/ordinal-lock#use-panda-wallet"},"in production"),".")),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("h3",{id:"base-class-signer"},"Base Class ",(0,r.kt)("inlineCode",{parentName:"h3"},"Signer")),(0,r.kt)("p",null,"If you want to implement your own signer, you must inherit from the base class ",(0,r.kt)("inlineCode",{parentName:"p"},"Signer"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A `Signer` is a class which in some way directly or indirectly has access to a private key, which can sign messages and transactions to authorize the network to perform operations.\n */\n\n\n/**\n * A `Signer` is a class which in some way directly or indirectly has access to a private key, which can sign messages and transactions to authorize the network to perform operations.\n */\nexport abstract class Signer {\n\n  provider?: Provider;\n  readonly _isSigner: boolean;\n\n  constructor(provider?: Provider) {\n    this._isSigner = true;\n    this.provider = provider;\n  }\n\n  // Authentication\n\n  abstract getNetwork(): Promise<bsv.Networks.Network>;\n\n  /**\n   * Check if the wallet has been authenticated\n   * @returns {boolean} true | false\n   */\n  abstract isAuthenticated(): Promise<boolean>;\n\n  /**\n   * Request wallet authentication\n   * @returns A promise which resolves to if the wallet has been authenticated and the authenticate error message\n   */\n  abstract requestAuth(): Promise<{ isAuthenticated: boolean, error: string }>;\n\n  /**\n   * set provider\n   * @param provider The target provider.\n   * @returns\n   */\n  abstract setProvider(provider: Provider): void;\n\n  /**\n   *\n   * @returns A promise which resolves to the public key of the default private key of the signer.\n   */\n  abstract getDefaultPubKey(): Promise<bsv.PublicKey>;\n\n  /**\n   * \n   * @returns A promise which resolves to the address to the default private key of the signer.\n   */\n  abstract getDefaultAddress(): Promise<bsv.Address>;\n\n  /**\n   * \n   * @param address The request address, using the default address if omitted.\n   * @returns The public key result.\n   * @throws If the private key for the address does not belong this signer.\n   */\n  abstract getPubKey(address?: AddressOption): Promise<bsv.PublicKey>;\n\n  // Signing\n\n  /**\n   * Sign a raw transaction hex string.\n   *\n   * @param rawTxHex The raw transaction hex to sign.\n   * @param options The options for signing, see the details of `SignTransactionOptions`.\n   * @returns A promise which resolves to the signed transaction hex string.\n   * @throws If any input of the transaction can not be signed properly.\n   */\n  async signRawTransaction(rawTxHex: string, options: SignTransactionOptions): Promise<string> {\n    const signedTx = await this.signTransaction(new bsv.Transaction(rawTxHex), options);\n    return signedTx.toString();\n  }\n\n  /**\n   * Sign a transaction object. By default only signs inputs, which are unlocking P2PKH UTXO's.\n   * @param tx The transaction object to sign.\n   * @param options The options for signing, see the details of `SignTransactionOptions`.\n   * @returns A promise which resolves to the signed transaction object.\n   */\n  async signTransaction(tx: bsv.Transaction, options?: SignTransactionOptions): Promise<bsv.Transaction> {\n\n    ...\n  }\n\n  /**\n   * Sign a message string.\n   * @param message The message to be signed.\n   * @param address The optional address whose private key will be used to sign `message`, using the default private key if omitted.\n   * @returns A promise which resolves to the signautre of the message.\n   */\n  abstract signMessage(message: string, address?: AddressOption): Promise<string>;\n\n  /**\n   * Get the requested transaction signatures for the raw transaction.\n   * @param rawTxHex The raw transaction hex to get signatures from.\n   * @param sigRequests The signature requst informations, see details in `SignatureRequest`.\n   * @returns A promise which resolves to a list of `SignatureReponse` corresponding to `sigRequests`.\n   */\n  abstract getSignatures(rawTxHex: string, sigRequests: SignatureRequest[]): Promise<SignatureResponse[]>;\n\n  /**\n   * Get the connected provider.\n   * @returns the connected provider.\n   * @throws if no provider is connected to `this`.\n   */\n  get connectedProvider(): Provider {\n    if (!this.provider) {\n      throw new Error(`the provider of signer ${this.constructor.name} is not set yet!`);\n    }\n\n    return this.provider;\n  }\n\n  /**\n   * Sign transaction and broadcast it\n   * @param tx A transaction is signed and broadcast\n   * @param options The options for signing, see the details of `SignTransactionOptions`.\n   * @returns A promise which resolves to the transaction id.\n   */\n  async signAndsendTransaction(tx: bsv.Transaction, options?: SignTransactionOptions): Promise<TransactionResponse> {\n    await tx.sealAsync();\n    const signedTx = await this.signTransaction(tx, options);\n    await this.connectedProvider.sendTransaction(signedTx);\n    return signedTx;\n  };\n\n  /**\n   * Get a list of the P2PKH UTXOs.\n   * @param address The address of the returned UTXOs belongs to.\n   * @param options The optional query conditions, see details in `UtxoQueryOptions`.\n   * @returns  A promise which resolves to a list of UTXO for the query options.\n   */\n  listUnspent(address: AddressOption, options?: UtxoQueryOptions): Promise<UTXO[]> {\n    // Default implementation using provider. Can be overriden.\n    return this.connectedProvider.listUnspent(address, options);\n  }\n\n  /**\n   * Get the balance of BSVs in satoshis for an address.\n   * @param address The query address.\n   * @returns A promise which resolves to the address balance status.\n   */\n  async getBalance(address?: AddressOption): Promise<{ confirmed: number, unconfirmed: number }> {\n    // Default implementation using provider. Can be overriden.\n    address = address ? address : await this.getDefaultAddress();\n    return this.connectedProvider.getBalance(address);\n  }\n\n  // Inspection\n  /**\n   * Check if an object is a `Signer`\n   * @param value The target object\n   * @returns Returns `true` if and only if `object` is a Provider.\n   */\n  static isSigner(value: any): value is Signer {\n    return !!(value && value._isSigner);\n  }\n\n  /**\n   * Align provider's network after the signer is authenticated\n   */\n  async alignProviderNetwork() {\n    ...\n  }\n}\n")),(0,r.kt)("p",null,"It is recommended that your signer implements all ",(0,r.kt)("inlineCode",{parentName:"p"},"abstract")," methods. For non-",(0,r.kt)("inlineCode",{parentName:"p"},"abstract")," methods, the default implementation is usually sufficient."),(0,r.kt)("h3",{id:"example-pandasigner"},(0,r.kt)("inlineCode",{parentName:"h3"},"Example: PandaSigner")),(0,r.kt)("p",null,"Next, we use the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/yours-org/yours-wallet"},"Yours Wallet")," as an example to show how to implement a ",(0,r.kt)("inlineCode",{parentName:"p"},"PandaSigner"),"."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"isAuthenticated")," method to Check if the wallet has been authenticated:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"private _initTarget() {\n    if(this._target) {\n        return;\n    }\n\n    if (typeof (window as any).panda !== 'undefined') {\n        this._target = (window as any).panda;\n    } else {\n        throw new Error('panda is not installed')\n    }\n}\n\n/**\n * Check if the wallet has been authenticated\n * @returns {boolean} true | false\n */\noverride isAuthenticated(): Promise<boolean> {\n    this._initTarget();\n    return this._target.isConnected();\n}\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"requestAuth")," method to request wallet authentication:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Request wallet authentication\n * @returns A promise which resolves to if the wallet has been authenticated and the authenticate error message\n */\noverride async requestAuth(): Promise<{ isAuthenticated: boolean, error: string }> {\n    let isAuthenticated: boolean = false\n    let error: string = ''\n    try {\n        await this.getConnectedTarget()\n        await this.alignProviderNetwork()\n        isAuthenticated = true\n    } catch (e) {\n        error = e.toString()\n    }\n    return Promise.resolve({ isAuthenticated, error })\n}\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Returns the address to the default private key of the wallet in ",(0,r.kt)("inlineCode",{parentName:"li"},"getDefaultAddress"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'/**\n * Get an object that can directly interact with the Panda wallet,\n * if there is no connection with the wallet, it will request to establish a connection.\n * @returns PandaAPI\n */\nprivate async getConnectedTarget(): Promise<PandaAPI> {\n    const isAuthenticated = await this.isAuthenticated()\n    if (!isAuthenticated) {\n        // trigger connecting to panda account when it\'s not authorized.\n        try {\n\n            this._initTarget();\n            const res = await this._target.connect();\n\n            if(res && res.includes("canceled")) {\n                throw new Error(res);\n            }\n\n        } catch (e) {\n            throw new Error(`panda requestAccount failed: ${e}`)\n        }\n    }\n    return this._target;\n}\n\noverride async getDefaultAddress(): Promise<bsv.Address> {\n    const panda = await this.getConnectedTarget();\n    const address = await panda.getAddresses();\n    return bsv.Address.fromString(address.bsvAddress);\n}\n')),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"Returns the public key to the default private key of the wallet in ",(0,r.kt)("inlineCode",{parentName:"li"},"getDefaultPubKey"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"override async getDefaultPubKey(): Promise<bsv.PublicKey> {\n    const panda = await this.getConnectedTarget();\n    const pubKey = await panda.getPubKeys();\n    return Promise.resolve(new bsv.PublicKey(pubKey.bsvPubKey));\n}\n")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},"Since Panda is a single-address wallet, we simply ignore the ",(0,r.kt)("inlineCode",{parentName:"li"},"getPubKey")," method:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"override async getPubKey(address: AddressOption): Promise<PublicKey> {\n    throw new Error(`Method ${this.constructor.name}#getPubKey not implemented.`);\n}\n")),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},"Both ",(0,r.kt)("inlineCode",{parentName:"li"},"signTransaction")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"signRawTransaction")," sign the transaction, and are already implemented in the base class. You just need to implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"getSignatures")," function. The following code calls panda's ",(0,r.kt)("inlineCode",{parentName:"li"},"getSignatures")," API to request a wallet signature.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Get signatures with Panda api\n * @param rawTxHex a transation raw hex\n * @param sigRequests a `SignatureRequest` array for the some inputs of the transaction.\n * @returns a `SignatureResponse` array\n */\noverride async getSignatures(rawTxHex: string, sigRequests: SignatureRequest[]): Promise<SignatureResponse[]> {\n    const panda = await this.getConnectedTarget();\n    const network = await this.getNetwork()\n\n    const sigRequests_ = sigRequests.map(sigReq => ({\n        prevTxid: sigReq.prevTxId,\n        outputIndex: sigReq.outputIndex,\n        inputIndex: sigReq.inputIndex,\n        satoshis: sigReq.satoshis,\n        address: parseAddresses(sigReq.address, network).map(addr => addr.toString()),\n        script: sigReq.scriptHex,\n        sigHashType: sigReq.sigHashType,\n        csIdx: sigReq.csIdx,\n        data: sigReq.data,\n    }));\n\n    const sigResults = await panda.getSignatures({\n        rawtx: rawTxHex,\n        sigRequests: sigRequests_\n    });\n\n    return sigResults.map(sigResult => ({\n        ...sigResult,\n        publicKey: sigResult.pubKey,\n    }));\n}\n")),(0,r.kt)("ol",{start:7},(0,r.kt)("li",{parentName:"ol"},"Panda supports signing messages, if your wallet does not support it, you can throw an exception in the ",(0,r.kt)("inlineCode",{parentName:"li"},"signMessage")," function:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"override async signMessage(message: string, address?: AddressOption): Promise<string> {\n    if (address) {\n        throw new Error(`${this.constructor.name}#signMessge with \\`address\\` param is not supported!`);\n    }\n    const panda = await this.getConnectedTarget();\n    const res = await panda.signMessage({message});\n    return res.sig;\n}\n")),(0,r.kt)("p",null,"So far, we have implemented all abstract methods. The remaining non-abstract methods can reuse the default implementation, that is, delegating to the connected ",(0,r.kt)("a",{parentName:"p",href:"/how-to-deploy-and-call-a-contract/#provider"},"provider"),". If you have a customized implementation, you can override them. For example, we can use the Panda api ",(0,r.kt)("inlineCode",{parentName:"p"},"getBalance")," to obtain the balance of an address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"override getBalance(address?: AddressOption): Promise<{ confirmed: number, unconfirmed: number }> {\n    if (address) {\n        return this.connectedProvider.getBalance(address);\n    }\n\n    const panda = await this.getConnectedTarget();\n    const balance = await panda.getBalance();\n    return Promise.resolve({ confirmed: balance.satoshis, unconfirmed: 0 });\n}\n")),(0,r.kt)("p",null,"Now we have implemented ",(0,r.kt)("inlineCode",{parentName:"p"},"PandaSigner"),". The full code is ",(0,r.kt)("a",{parentName:"p",href:"https://gist.github.com/zhfnjust/4448c0c10e2352d0b7f6eeb86dbd6b0f"},"here"),"."),(0,r.kt)("h2",{id:"use-your-signer"},"Use your signer"),(0,r.kt)("p",null,"Just connect your signer to a smart contract instance like any other signers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// declare your signer\nconst your_signer = new YourSigner(new DefaultProvider());\n// connect the signer to the contract instance\nawait instance.connect(your_signer);\n")),(0,r.kt)("p",null,"Here is another ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/shubham78901/scryptDemo/blob/neucron/tests/utils/neucronSigner.ts"},"user-customized signer"),"."))}p.isMDXComponent=!0}}]);